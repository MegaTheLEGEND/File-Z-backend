<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c5392ba3109f63ed48d88a0cbf1b65a1f01cf1ea5e037c46a2b4720719ff400341b32bb24dc346c904d1908557386aa6347ddec7fb1f3d684086ef98e02cd05f329c1a8f219a6f8a0557182ad9096dedb9a1029c34d371f4a2c989727b34c6982cf4f965029b87272514f5b5795af8ef654f1cffca9271dc0a43f33acb0b5e7c3699b16ebc6a4ba32e1c9b279ca99261e1bc3b1591bf4f23981e8cef7c29fe2063d7f3ee8b02aa888f9de6aec91c85c0ff6c0eb0aa4d6db18dd2799575cbc2e73547736e009f0d5b3d91dc77bae132b0c2cb1b832dd7f52cbe9546b029897b4baf79a649999e5008c0f544a2a94c5063e26c7e870751c76435767e70987ef87a326d834b6eff9e3165975394cb1784f0ae5c690e766db027fa63f3cbe748d36974dddd893990a589e8e3863739ce5f2c92d914ad302376b78f0ad27081440da6dfc02f9f57fb876cd6868b3dcfeee15254b70f10e2fd7e9f467948608a3c9b09690f58ea7a153bb7f1a2b135c9b2253771066c3db3bad2821731535ca20ec731db1cbbbecc07ca17097e9d1a69d7c3d3a9a4b6679f4014ce20ec70772f4c8bd01084631d3b5f91ade196ac92491d0cdd19ca811d3e3efc14093176ac9d1db4d1cb778a79eba44ad13e3e149c80f91d6d8e64d2f2c7f8a896fed3d8f24fb5e47fd1fca6e7b042cf29908ff31df7a04da8e1f9a1a369f7372039990d50e2928c5ef86dfd0b3a776476cb0bbff976393b6427c4b42a9a045e9d712e29bddaf8a630225401aaa523b55dbc1c53cae1b49b93d877e925d0a311e643d3864391804baffabce2338077941999d98e5d5a6fdda11ec00bc973ed981685251655c74fee907bbec8f801e1f721c5a3d995b2947fb0f480a2741512b2c9e4e20a954459420736ad39e1be264f9d5f1d657abb878a5713d0113550479af4461824b1acad24f538a3c72885ded77ed07d5c66e6d0bc2f47d12d4d941da5f2d8ed5bb6f22ad4d2e73895392e40b8104b43ce225923d0419d4793e66b234764ae03361114a3c4bfaca738387100e76db2b7f0e50484c9139811a76b5b8720f05209109be8f9d5ced42a0b953450937ed0c188cb219bb14af28070270977aa36c27508c87869ceaaf76ec9b635c5108dedd7704846a820c864dab6e1607a5e280cdb8710bf6e334bd03a75ecd4e7561761175c7ee6043b70da1faea741922394f4efe19d76020ecdb554140379523b2b6908160666d655160f1ea575a0def93ef52c1f65d1899c923acf4b4954632850e960d10afb9fa3276c435d4f906b432e62561461a1129e06d64bbf3e3f625cd5e8f159377af2273c393d1b32caf6b5bdbe9bd04ec67aad2f107015493a5744c3b844d23b061389edf1fcbd1700954a54468b01e3f69a9f6dba1a58f6ebc4618b1d3c219dfa042124f2204a0559f68daabad992f4ed8a88b6c207f0c41445e5c65f55d1b384f1c5dac0c57c98423893df062ab5c0ea8803d3db52d027eba6f6c9396de3811db2f37e15885e259e6731a55285ebca5f75bb9ec2a5b1702821cbfe0498432ebb9d9e53cb8598801e75b9f86c47f4a9537a7419a670dcabe1fec4c821936741cc999e77ef1ab4d99a5a44d84a3266ef07d50bbf351e8c6ad8c3069951428e54a7999d868b8ec13351f969a5dbc6f69d173c2b259b0f8ecb4df3fe34a2a943df35446eb205e9faf437fba9183526cbb06896fa5a3bcfae4a0cddcc5f6f764b734c921952af32e7f343a4f8828042deedfcc48c83db1c2d56fda92e88e7b9a0109a61e6031d3a4f8a4ab9e4641aed7b0b1549142ea41947138d74ac6df6ec8ccd20c0e98bdf601f6dd17baa7078b87c0688a9fa99109c82d2c9d1a3ab787274fac927c6a0b4e1b599601f6d265026f397a103812846e29ade52de9d321a106b32dcd2fd6e697ece41a176d86a4234ac40a96ba0c58a1c1a19b61723b32241d4f1c45321a96211400eae76121be165945d4ef9585690390c8a0bc6d7e739b47e28e9190e06a08f9532747f1ace585d17fcc892cd317475e669eb3c529e7156235a2b5e2f0b85cc8cd6686e3cc23eabbfec2609f7cb92c76a9b75af298ba8c0f085cc71381c2f3fc27eebdf002ca3f16c31b29d7e2bdd6cdc59c08539c0d72cda62fc94f3762808916705e648144575f5fc53fc44f25ec50b550a3abba0f01c5b0aa6ed98d874c053160ca52a7515623d42454a71e9549cd0b543a8ab6999c0ef5ffe02569c41ad524c2d2c14d64a69554f1c4a2f25a490c85b5c4756e72f1cc7b43e07d1cad2d46f0d0f39803cf653339d8fa5a9562b94e19405131f1f0a2b7895c9a1f3e4024e090139becb27c2d46e99e7c65313e3fa7e9f78d735c06ea4ec290e4c6dad4cafd495c10a13d08f64411854de87ff3d9c4d2f2e18bd67d5a4b0b6d0fd4aa28d68fd7cdba45f04d6dca92a730d9dd29410a3e3eee98ce1b60f308b0cab3e7d172fc3b8ab4609eabe4a380982ff402037263ea0cdc630bb9ccfafc2558a44d5996bb389fc98a0dd30f5cfed8356959dc91c8e0b788bd7b4b983bd33b2b06ac3f662859e2f574136faf9fd109be8272dd5e2f18e0883dd8aef9ace1bd6a4196f30fa060bfc675b1439ebbd4bc1ef5fe9de4f71fede8e2365f65225b3f9ed8a9d46e800c15e6dbd466adb109cf2c819897afb4a9a2fb8d2562833bd2fb0edc31031dd68a2e341520ed51e4b17f8b7e827b6dd96f4e739e90ec619dc5710d0e273b082269b9486b28e3b9d5a394a7b562d6cf6fb1527a6aee856f1e6ab93ce6b26e9fff8a89798ff33b9afebf737c04bf0d82d860153897df5baa48a32b2063e92ea696ae579e575ba4448e63e0a810a8d37f863d9cb55f566303593ed579bb839bb42a48810c653a6fbefe787ea187450b633dc6e3816f0a4ee6dfd21ff1598c500cfe53caa989d064a329af47fb37bd52962bef9a86b43cfa1fde37ed6f3ac547a17daa4a79c4244943b7350b948b167a1911595d4f05fbd6cafb47e12d0a16289ba63da72c254083eb415b75f8a95ffd65f307fb4169a349ed1694767a3dd17d4da0e1c545ce2c2dce6900849d44f2b363c2f6412e263077aa4675db27c2458c09b46cbc073996958c49cbb33922441db0f2dfb9630995f2c1251d6be4d17cfbfc2cce635c54d8b91db7c0497755498cd9aa6a376771b34f24d863fa25ae6c8628450593cc51b886316f34cc3537ee748a6dfce983434fbc97dc8b690931f807484f9a39b57ba8289f78e7bf0e1478b2f31d48c60e5b191e5d441df2dab915004c07c4dc2ff15eea7056b1696a270f213fd04bce0d00499208a035f34689a449ee0d4c27bbdadb8998351e97a35f3fae0a2086932e15dbc55ff6f72eef5fd702d6c6f6a7bc6eaa42e7c3de66f5a0b135eeacf5e9bf770d3dbc46191bd465230fd0ed991287d7d30794e3b4395c27f38b22a6afa5089ac5826de6bbb57e295eca3cc759ecd66c716ec6cdd452b40016ebf52c953ac22bb5ad6e80e8aa60c048c276a180decfdf2ebbb653d59b0617510be7d01a2583bd644a619c3a8c49a3cbc9dc70f9e150c6cafc66a2f41651c44fde5d279509b5d578a7f0904b5695026bd7a2323b805dab990b76183d90304a78f088a75e6d658d0b3eff59bf583efaa814d68f0fee165b630cd4e895cacc9ab217b680569b6a5c590cef4362ecc94d9f06c96f5192bbc852238c01b300d5412e12f5bc9e058d484865664eb949167394acd32b6701d5f01b9b4cb09c25d32d0e0a3b59ae7ae038a20e214e855d6ed8876fc89731bba9066f1c409a9a5e0310a69b2c6d12da0bd066d4e06806db706a327117ac0ce8c5cbebd9fb0838f849448ede279dc1422f8f5eb4dce09918ed6d43cdd34d4b0c082361435210b0c802f88838970600e4a4b30474c9e4d8cbdfde275e7a2b2f9fc737c4ff2e916b6d7147e04d58c0319ad3e9c8abcbb0346fc0865e28e6052c3d8cd0bfa0c869061af0669cbcfced54b5e80d84e7425acf67ab3b21fc3663a38fe3d6582e320d3572bd5c4ad83c392a49a6d822c2f8910a186a51ea82721cf2d6f32cc8b6884ed222b2b982051897a3ad25f8d45326857e3e92b8d69142aa4744aea323a219b59a8d9bec13bf321b84b467f00830108e4618d54b76d731125115fbfb28142b588f77b82b8ef7523551f1404ea60433cf9bf8050b6378474c5dfc71bc249b568c8fa9835c8303a54726db224ad8f2b5471b6bb1927c06982f0d5dc0bf5009f1daf9262302ed447e7910f868e0ae400b2f228ce84066d92a920021ed9eac98444cfba0a8e7bc0737c27f4a0f605d7a3feddd18c1fe3149d81513dc2d9d98abb854ccaaa359f5b479032cecb5de5f2a1ce0162ffeb0260200e6ad36b1e43abeca1912d76fbe4d10d12618707a493c6a10512a87047291e5a3a52044c95d8b22cc33f1a3c1b527b2dd3c625b802fd2197e116118173d5b346816751fc7a8bea7ee0e18192c48bf8550bbc91c0c54ff90c56ba282d1f2ae1651e39492414288295672bbe9f35ca23121136f6b8e44a84f4daae5b52da08925257d619d0882af5225bf81f909d95a1702d854aabe446c1e1d88e91d8e5a01b52311d5299f7661d9df5cd4e6884b3826d10308e55db2cc4814e5b9f6e11ad51bf35530b6a42e432ae0a54129fe1ba39ebed80f5a10c27e173b3b58d32e9afcce0932ce19a2b5a179b1229399c64f800f33240e40246e8b7bed6a395c9e33a4dcf934997969af202cb1ce92eda5ec399a50efed7a9954913d546f6ce14be49e9605bcc577dfc0dd98d5832d118c097e4af2b69589f83e130e1e00462cfbbb248553ab282157a29eb9eaee6af2230cea78799404e6a9fd4d4c9f80eef198069d67ccc434742855eb77442c3c1d14fcb928f669c554ddd87ca6e8d024469eaa64844cc7342fef691be85a7b2b3ecd3be307ba5430d9b4dc056930294b517cf203899d0e9b1f4ca244797bd6d8d89c2357e4f8783ab58489120d05a3a46d71a66d316c749125e38be0bcfde65d387d804d6b10cc5d4eaacb1192ac7fc1b2d633c90169014360389ff8c75324379be2cf0b2adf757956c1546031f0a1bc6956b537ad4d6ef84902b31212be58473b4ac635209dea08c88aaa5d360c18ee35e85488e85239064c9bd8d558984003230d7531773bbf9836a2dc4465b3d3120d3b479bb21ea85de2871e5366b1a6e734898e61a75282f56762d0d7a413b5b921e7522ff9f42e6a12b74de547fcc63a4ce08a34f8a1e9db725ea7050c49cb6afcb026485ab82d15b0ad5583d41d6e694e227f8b195ed1a0b3ea000f9003620119085003552ced75eb911b2a19dc64b3a3bae4fd5d6c63d215a1f24b6ebb362ba8fc05c835b7eb0661365806d46754b8f77ea086351d8799ca9355a2194d0bb8cbe64cfeb584faac6d9fab1366151d64d48d39c2e9da709e6a7f24232008016cd0ddabe45f63f870b046995bf5c706e1551d5552197e95909e2502a7902d7e58ddbfc639c220dc0490219a8bdc7aefbf2b18ba7cbd39d1f0b96dfacfbad80c09d309ff9bc25e05362611b56d5d710027ffcbb2b53243250d7b1c28bce35d8c0baa339eda0d2798850668b46a7694d969d486a91b0920273bb6576fe2c835ea7c0fb98f8e91d3acfb26321294fca358d107c84c963eb6fea260c1fd96831f5e52633e91c8c1ebcbef569967fb6f1549fa6e216a0632e53b33125da56ff1ce35a128dfa2eabe3910da18432cbc382b536d0e4fa4c8c274be01930775053c2b124da5ac434af2bcaa9a58adeba3bf01fdda3df1d3f29a17ef8842a90988d99b02be649c2034dd4e1a18f2f9bf561aab2782385cf22d434210ff1c2161cfc451c61f384260dd9e8b5ec33dfae717aeda46d3a286615e382b36b01e6ff13fe01362cb0199c124efc38005a20dc211c2bd829ef96172c884a84c913f29691c9e711aab6b7852a9e4a17ef3006fd312a8d1fdfda4aa9bca8c634794a38d5281a6b42a68c5ebad010d1c6eb8e2cd5fd9b7901f360c6d6131af3d7345ecc35f11b2c0ba29dcbb6a28cd4d7ad8674aaacc13332a6bde0a1ed2bf0f20ba101407c31da419b7824608c39ded7b983f4533443a857c346542ff82fd5aff05c714ddb06acacf8687c63d009feafa3205d1039e515984c30dcbb1f432d28f206f0cac75cfec78f07b0a90715b8a9e6c6a51115e4ce8969315731e4333a605ecea34c6e8a15989ad1b52216715287cf8db3671c52bc53336ff8919f98d8aa0cb31fb6efda503c7a5ff7e8555870d56eb630c4617aa789cec46f6948e36e1e65d2eedeb3163deb7ee1c454166958aada420244115b192030549c0e7e9fb468ca4b1e09eba02197718e713042bb72afa4638e13ea106d4f6d0cd1ef5e5aeaf2c733d745d841f7e6a326d2422be19616b39a067aeca275d7d843315ca87dc4af945233b4ee36c40a40f6ea56bcb1bb088b8ea09a9bf12b3bae8c84a5f2ba0a9c24ed231523c6e62cdc84a77c17330582c03e8342b7352d247bae9a00ecd6535b2aefe62d8ec6eab8c858342b8155e48f8698974b12196d7c24d08be16e6c4832e0f1fd1e4e4b97a4e8ab3a26b27fe30cbcffa7aa4285038c73fec3c0f0c29d36fa02dab4cfe4f4f28f6a50c3345597e239060ee8fa794a6d907b72f7038a107da4192420e2c69d2e68bb5e05c421ebb755761d94e794383b730a1fb1ee3c4b91ac7d1054be0c6536adf8e6fb4215ea14f9ffe430e05d172f217476e33da6e9cca99fbbd6427343c8eac35d55799026303fb544da08dd9cf6ff596c272ae1c6ab78f9d97c05427154dc9b6beec1a2055af96ffce68efbbb0b01c8275864f6df1d2d2cd0abb9fa6cf01a16e115ee49e31807c4fbe6b081b3d8cb32934ce2e017e846b6d55b9f150f3e1d9f40d297e1bb943a57bdad1979760f67d1a002fdaf8a125f43cb13fd089a07f769afa06be9e5e3e1b533b5d40b291dc0dde3f12a5d5b8f095431f799750b4e5fcdb89599376b734a619a1e26f360534a14cf82489f2b08dc1296835497ec48e60820d9fff38e4596ab449c1f0b00fa558dedd213b4b1b69edc1149c64f8eeb30858bd6cc401836b3b2f22485e6874d0b4954b32bfd9ef44b9098c490554b322c116888b62948ae223c7a842f8129d64f02943fe577bfe18a4ae52a2f19d8e10501703c545b5f3ead1fc3971b42e5a92390d4cfb107b3faf78b3850d3e0f6d97e061a87addcb58bf24e101ba067a3cca66c368900a31829c1bd07dc6d0abcf4993279d14f31215a591c48339e25a221f91317b5c389ffa22355869ff5a9d45f10c83e051c875b0a3e00d97b424f866d3138e6243e3c531e93356e9e59c777f4ad938cf021365f949d2fd8cc04d3a79c4debc9279020f34e4aaa9ce5027fab8bcf588569f8785a7b0e822abce78af6f9e7a7524814060fe613551cb4db29edfeffa7b3acb4dc324ac9faae7cc5324936d5ecbc161502bdae4ef814b8c99b0359bf928e500bb402d96f293891de33553e2ba4799dce566f9cf98a092b0d2617190c12f2865c7a1cfe00b8f30a61ddcc1dd4c84a0754337a26d6e6399bf6ac1aab2b974b1b28c3b54467ddb524677ec3575bd51d842ac9de08c8a4d78c99aa9906ea6cca8ce78fe14a28987da07d85d228343db890460c6a13327fa3d95535c9591f0c1681ed9a3fcdab93812ed43b9a6fbfec681f3a2f75bc89c11208edddc2cb716c52c85bc04102cba76d71917156b5345d422f429908ac5eefd51c40d18207f5153d9b6ecb0326856f05a62364ddf8f99846cdd5e944acef5f72bf04d2d61fcad33ecf52436467573ac45c1d03627e0230b3fcc93be5ac81335b7000f518c06d04b97caf3ed1495e479e1d86a8ae79dbcb23b39bd57bb8437e3190f2c024a423322ee006c77bed5cc7ce59ffcdb7fbc5a13c4539e91110e5efb840285810effce11898f5301a78f5952ce011a1bd2c4fb25a32db70af008725065ef53a01bc1c6091a3806f4f4f68d1c6bb5b755dd97f091b74ace1a9f45bcef9efca09ca820e0eb2d3158d69949320b2f7bfed29bcda5121ddf326894f6fafed3e4530de315f73ffea8b54bfb20f3d19668bd80bbabfcab94b5db62c83a42caa29fb8673cde1770a7049fdf615ee29247b9d001e3c20a0535f9dd4f775709dd5e00e43ae0991989c62696df5c2a1bfa42171737bac84da3a3dedb3a44021e1debe8f28605982fccea6cb7b3899d4244e9628667f03c5f743861194f501fde1c9f4b3cb7e3572c5425687c90259a5801932a80fe173ab1e10574906e43f6d806d1ddea59f5965fb4a6a397db17e660e0b280c95954e9926e86231cbd3f5dd808b407b35d4469172e6a532e5f8f894bcaf97fe9a3fc213990b54b2f96a529d03dc90e7205c39ecae2b36424cf7320d80629f69620cab6e3db859cd820f241da0c74bf9f6f3a410f60f1ccdb7f099d099cd9934a34ea2a44c6109c5b198be4e698928a327415be73246be288e45c647190fdc987a134969b7bbdb79051edb8deed3ca55f8c5b461659585036c6df965ed08071f448d90360240cc699ac39cc20a9301b19d429a271d2992ca7b64cec58adfdcdb0622d78dc28f670c72c0d717a6fe26c857c9f5279d9d3cb48c1d95e39b8ccddb18c480934e78a56f723b2298ac002aae858416101d959beef2085743744c94f8d849ff02ba181325e768669a6487c2e3820f2b9f11507fd42784a4f8f3264028ce64c3fc8e25e422f5ee0cadda20df15a44a438a770192d4f13d612a0416f346d4734471850e5e58494af19b15d3b6bec0c943e22a95922345118d55145672241ac3253c925772f24d788c91d4de2f1dda85b7c41925a179937eaf77af2383e1589b3c1593ba36c23773146e2ec9e41675b1f930276c3ae15ba1e1959a1dd61a2a6bab37011ca2a6d36d89056ed3d9bccc2c4c567a84e7224d9f96acb0afec47fdcc3d6a1bdd8f516ce8d93b50a32f4c152828cd64f4f428e1408968dbf1f83f221b341c548769500a530c36df30aa7787755aa9ad3ed1d0ec4e40948bc91d4cd3094ce086a2064f7a186b1327f7064bcf86fcdc18988e6bdee1e0bdd0c4e04f190d2b53d9a14af0ed8d39e4b69f195ce27ea911f2c00fec2bba96c6e6c86bd6d26d99709481ef59233da6f7d68036a0d4e2ffbee8b67b052c9960c003b2170619e0edc2ad25cf6216dc99d37c1e585ced75b0695b9f4bf7f8a3fde78693dc45678f9cabf62ef10882855346fa4a99b5dd9339b435ed06250b8a1cc93196504cc0bf9f956f171ac9838926f00bdc83dbf71b3abdc0f74349c3cd4b109791fdb6314c6c5feec02185e7d36621762fdbd917da0643d3f6d022c9f4bc9ecc21a22b8513204d76b9c3057b87397b48ab5ce37e34cf991b2d16ac0903da0479ce998c9236048fe3ef7ff54b1f946edb6ed5e7ae8bcc07f829d913303bd98ae1b7e49ada4a1503b87d35dd26d2fad3d5e19357f40a1c390e2e32466f740adadb9c3dce08cb4c06a8c4cd6df2796274e74036a7701a519d49961a19a78ee1e815adcdf415a50bd3072c71f0279327364aa535355f39a70b1a599783548fd1f7eeb935118ae9b94cd675dccdd840c0ecbbe3c42e3cce877e8a50e708abc2eaa18b87ed70adc5cc84fc99b0e0fa4cd31fe961857a87aa95e6721abba136e477537b18a77429eb17e20899ae44bd6bf852ea1e1b473afaf039c1cf1fda3fd20782450f512b8011029b85f16647349f817864d6e359b771b5b2c2b2b2527a8d153cd3e48723b978872ecd7fa5ee6b64d3e3eeac289bbb792f790dff54709f55b0d19e7f33ed68697f0df92ed81c932227f247293a96739863696e423119737af333110472be77d3c6de3438f3b079cae98b9dcf56c7dd83e9438a0debfcc9fd859161fcdfaf1b8d5303cdddabae05ca3e534f1422289324ea805c59f905123053070b41ee2b5fa31e712e6697a4d029467e3d86224664b5eb9e294d5619320e66b5a430fc668d68e22bddb93b0afa6bddcdae97a4e663495f053c945f69a312a14dc39a62aaf2633bb18a947cc5b892283bb830e0f871170863c89714744b59835ff3d772af053fe4c8cf37fbea33b8fe3f7a20d860922ac9e19cc256375e694a2646963f253aacc47f99c296a9575e70de16271660b0ac991d46682863a1a631d21a2e6328565665b62f63db6c912afc223460cc6ef0616d5aedd8812e13ab1f0b430241eddcf0935338c20e093ce45a2dd3aacfb5cf92cf6e7407c1c3b87b6c74b22310875f6b32fca4d8ac6a6877b16bd8ad954182588e4c835ca59cdf506a174ede5bffef6b147d50d3f2b8b2511434c9e7d3aaa73a2db6f85a4ae42296f86b2828bab2b9a93a71d48a45d00df783d9ad18af11c658fdb2a9567da2c1115453ff50be83e538b95d5d9a12044b7f7bc86f307f7603a8d6e7be3d16faab2dae48b3467d9c91c1bf873ccb38425306d5ef31e3a04929e2aab7baf6be292d4732b304ab69268ba6181a28170fab53bb7728de49ef62250903683549ebd8448209ca78c95a918ff93f04a98fa9237e5b0a213efd7ba0226a540d9d70a927e5ec4726526e3621a8c294f4513cc81f6f3e770244ec1b909de28656fbe4f496828725447f4755f4050772e5da8dfb96163ee404be72d940eea801dfbc5543862ed4a2c123ac8c40c635f22f0fdd429e8643fd1beb1b66151e40fa345af904e5c5ec468e38144cb9c52a792c28557963f39f13d0498a973aff605abf4bf6709701c897a494a02b531298e6d3106e22ca5dce1d126b033804269e088008c61dffe9976a05e835ad3467ef05698d8ad024de8f4d4efc4d1f1b009aa2a99dfb75924d1c1b6b296b894c55edfe8afcea20e5409bda1be5d658865a54c89a3587b5116c698411a391328477d6d0601b0f0c51d1e96a33aaef26fc4fce8b7513546659fd357e10bbf9349f2a101474df411844307eab6d8a29a19ce9f4b2a0bffacf25c0599629f3a50d31a82c435f9b6d357f946ee8a488515bcbad71a9933fbace6d6f191c17ff623d0efdc8b28c8bf6efdb0993d5ec6773268eec24ef5fa04dac621ee577551db11a2384000fd62702fcfb26ba7851e42313df0e9dcc6450e82411971a0e723a842cbdfa222a19b33da7c8c10002e1fdc94d81823778886789a4f6d6a513701b9a4c49efb9038fb50c13ae15d23b486dada4fa567224393207b4556a670ff922f53b35a49993d59d266542e7dfeb98612cff5a16f9aa0ce564bdc2e463407b1a79c11f50268f2705d7f4705c03d3db1c5eabdadd32e1b6b429f66d96f3be896a28fcd8b9681c00f3add0d299fd17b22e3fc065de1a5cf4f16e4ec819524800e231baad93016603c179683c82ba4cdb338d834f39c19a44b7004ca42cab92848c2f57e28304e2cadc313356544cfbee25732f061a233b75c315879779a9350243499e6b2dede16885117f135cd2bb35162f19eed1a679ffd736400c465c23b70f13d47787d64d42863c87e175a53d549b35ffef5f8ba4473b411fbe278b092b57c337be3aa5e9e5e20d7f3d991b22545ff628f1e7cdf58f72190d2ce7b643dc367365e46518b2da38749ee02a8c21ad2a187157f28dcef5160421480fa9e83563b8081338c64f6ae86c82aa127cf611f951b134e672a33f33b6bb35cef870a7a85aeb92a82ee516c03d57c0d30083be0fe7347bce0b249f14e1fb0f0d78d826e83c07a11e341a6ce309c52bacaf8ca058eb74c70de1cb4d94203ccd9d38a553958b25da8258360a1ba097ab98fd8caf957396686796d224a946b7e1b9c6ab1ef7ae59f2cb7b525437610aeefc1a8129d2a12a47d3c0dd6e808b37ec396999207d726a7446343e1ec054ad014e75237f4d5ec7e5604bd0e654307040129c4f3e15ec9586a84993e070a53eb6b4edb44f1b7143441db783b89837dc04c20970a0489481196b38bde6650e1d978e86600753fa81b921fb820ead15717dfaffdf6e9568167b7d6123715693b31efdf751f60eb201fec24a812ce77cf310f874d855204ee7e5f933c43c78842281d3e3c9e1fbcc53ac0d57727dc7c671c76b24047930cd38309e67b54b97b9b0739624c36af7ed1e2755388fe3707f2a5613303c01fac738be2c7321850f26b43ee1a494fa5e917429f019c7ddb5b74f50be47eaec68e7e528cbe91db1a828d715c575325507cf7f343c8224ccd103eb7560512d864be3dda95c7109eef7c5281350bdf65ce76e247ce010b39f6d62d793072bf9d0deb43a77b8a0e73d84d45a3a1b1acac35afe7a318913eb82377e44103d69c6ae2fb076fbad2691703c569deb8b99ccc2ddc2aa571c606084719cc7c1ab99336084c74d9f87eff632ced3f87363ee458d6623981cd5d90bf8d74f57a0c46d95ff4b6a4bb25976b57adfaaae4158fe3d6c265593138c511910d29ed5a3beb89c7dfa0996f4cf4c6e273b91cea89141cb2cd823f72899bbeb97c505a2a574ad67762155e4c774f34eabeb35595cc529eca1db6d0207f1c72f59350896cb328f733f5ade12f2a11abdcd9ee535672155f81de6a77873af207f6c3d3f5e8d16b868f3b19b2379395e322e91acfe002a9121eee6839e1abcaeab17a715f6cfb0b8691755f7574b02530fde25c67353640901c51dae191be07311216422ccb0ae3a1519ecac5423fb9a1f1b2532231b36d2132d6a497d550a19111ff902b4aa481df2de31714cd179aa1247f30759076601846dd370c7fec7c718c415a51dd9936fc8271b83270e027f0632f8ae67e1187de10e29c60cfca84756d463217fd084a14974f9afbbc81b434ca1d1c09a855e6274565c2bb3f0e22dd0f25a4778251b157db8b258a6ece8ec0604f0c6c2a6fee2f9c6d1f115c304444b55eb0a11b8c0e6df3362d275bbfbbd22417f5567cd5d2e05abafe56632cb57e2e3a3bced89d073354c60b31c48bc36b6a80a3aa509fdb0f753a0bf7899ce874a39c21f33e8a17e4d15c1cd07a5db2db9ff591495f5ec9a010e7377c3e7a0a79b7498f7ed96b8b55dffed6f8c06b6c4741e42831e7e842d6095c0cba6dfb70684981910a3daa5fcd5a92614490c9a130ffd9613fc462d792e138a586252ed58b1e46a979608136f12c125db7e3952702f971e667fa160eb645ef70e90e2833f1a42c52aa4829d47450b30118ee2c583ab8c8e72282141900296c10a6e731d3bfd2e9b6cfc21733f2a078a801eab28b6af65f5da5fde82a0d47ee0f54d356cd179c42b9bd831cc499c40ca496e85aa142848d087de624d3083eb08718afa54b6bafc8d2c706666e36b87df1cfd4dc936251b172fc89f79882887e60e2ad616d2a552915007c9f7bbbc768d5871fdc9cf4ca3ab862c69b00d056e03449cda695bd0eef086893aa850506725f3a067e840d93fffda53dc20ff2d0328edf2e783544c1366463f38165838b590655107b9c5d95d94137e42baf9342c9ad579d6af881fb6ed689b083a02cdd755970e951d9bd5e2ca3e68521ea427c5562d9600694a67a1c2fdd3df410ba5cd858153088a098190a32d5b9c6922d99b744e5cdc4a008cd4a9868b513801678778f80d089f79520ed5e50502c3c71fd8e76df95234213b808603ed42555a4815d4ad14d98e94bac8aabece9fb848af20b8a4ff4bcda6b754b85bd4f283ac7f85d7544265121baee57376cb2ea2a85633d1ff0a9f19ea8c4c8cc07d56c295229f07911d386b4be11bbb62c8d260846ce5f5b20b6319e9847fa12c69d3cde68d6a51f886289020bbb5272832bd2f1071ff07b2a0d7c282e9f27b18b3d4df03b3cc75a2151b14f5efb5afba23c6d59c25c7b3134d63560ceff218a20eaf9b7762a031f4fea1648e71b0d2a5f6757b4b6d9770e36a27776dd320eb4bab7246ce31a788b8595ae12aa94e982628312757b3817434dd956e7fb83eb5961c64198a90cbc6b137cfafc5db53ab6b824395914491cf410e21b2a59c57e2582685e4ee50280026c8987c3dce4494f5239e96c2a9f79f5f16405fd7e4f4e7dc61888255bcb06dec82b1866e374694d499ae3dfc57fb507d227f29011c16c09b1bdf75a1a740551098eb37b54c127b9a682acd21cc3cf8f5c78729a4e2fb2b97680674da4d1b73c857a85248b26e8275651f7f24c3a9bd9edc4a0b91fe031a71e6fab00d019a02c01720c232e1cbf2b8ceb42e5836596245d6c779ecfd571c3d0263ae26ab7266c9c1ae74af088cf1b87176799f2e65a1466840182a4dc27df92cf9b6f1db22559e04694f95a5e37627bcbb748fe899c98f99311dcf0d2d640ed215764e9fa51719745c334ca0dfedab717511803c74243730ef23e9d1dfc1050ca653825d4ba1d94d8dc16846763ce9eeebe73e1141b1f7d50bb02ac10a53e64bc9e2de3ecae8b6ab2087288c240906c27292ab8c7472bba616bc1ecf31709508172d9e2cdec0f2ea39d5060a374606c202ee490a56b275fab1b34349a754a1635408ae4b116fdb8a15e916078242fccf6a2b73d12171d94e7d884f90466f7011ce4ef33ae56a6f7c4db143f753cd0efcfbd2866ebef3acf942f5994bb168c0e3c5d100ff887e1319066075ff2e1a2a0889d4acf65fc37d5388765155e23438d0927b6b0a3c3da6a5342927185c0b4d968e9e6364bf1b2dcebc2f396a6bb6b11e571e1a3a6b186fd8c61b14942781c67e2107b1ff62dc361ea57b4275329c49ae0ed99e3584705eb19a33a7bd8b109a494a5fa3db1c5191bc824dbbc7dc07d2318f061937d67f69bd04f5654b26b1c2418b0d5065f50a734cea459a4a3131b9133d133c521a532aed184cbc294bc5289c3ec07426b603dcab0be249294e4153c49ea9873f0c11772456d6c86d536078d62c7b1b015b6c6e9db0c6a1b533f87de9da07596124cb1f881e3b985d0956cdabbda275b01b460bff4151b142b7819c099b8930ab294b95ac4bf1845343c79cc370a6e7eebac61c86aed867ab6707f1744a05d5ee1ac4601b29481520b9935d07d8894554ea56b55a2cb9ae0ee619966960e075c0ebf5799e52bb9a3b2445868d55e6b547a9b782ed6c756937194f8e642f8fcd032d2b6413054f58d98942c6960b50ab55c0315c4dec5e58c31b27850d822372061ec2ccd3b7eb80cc8fc1da70a4d295e677a5d7fcbd8cd38e0c6a5576fcf64b230c178e87e926d82dd736b67b4227d2cf3f0a524ba8d48e6542daab8c86b584bae3590d80ea4df3caff72a4f7afd756a363845ac44d4ddc25c7a2ebb874199934710ef3db047905e1ecc03641cbf51e20735e09887b3fb378db879cfaa326f1283a5bf6b6ce4ceb224ad57e5dba833bb2b16bb10eac55dfc6a91a09d0d13cbc991e13e4267117519f511e3865c46e8f570d06c52595da125b6695a36943e9752fb8dad998a9120559cacc1cb2ce455b508e4c22922ed4919300f960fae82246f68a5fc75d6377496edc6e44b318e11adcf93ed493b42d0dce539a82109436569f34ec45c6cc5420e66f8235afe01dd90ce22c202f8c0663ba858aeb1b7272560cba6bc9ebd6f42c997b9a295e0a4c461ccf836fdb5c59715c8d5a4f076c75fb73566b53f0337ec7f9df667685eed66e374bf916fa9325869e9a76a9126dd469e6f39421a4cbbd375ac91ea4abf5f2162af47bc3281c47fdb2ceae49417e138076ce2aa3cd3b5ed63c52491875a7f9771dc2b1dbcca12cb3eaf204b867b23be9d286872e54a05afa3773b993610c18d4636c7a4c8853420e384a34f54562282be194adf841b6ccf4ff3584079e83774a839bfd7063ee5904d9c3ca308e61ac8b46710093a5c2ac922ed5dd4d9fe004a0552fe29b89f963eb4108d07513f24be62b3b96ddc52ff225a45fac05fcee9227a4270f4f0045a3427c5fde708b4598474e2d2eed5fd6b6a1f4d90c76713262a96cb36a389d4f408c1f849156a62e3f765796846b0e0ef2d5795771938099d57a58be065dc3d930f403591c531ef2be7d1df7338e6ac37f03279def1de36724284b6f4f8bfd8c78644ee4cd488eaf8aa884437ae3a22b1c99a91edaf7b744e996b52e04a4f35c8c3798bdaa7cf72c458ab7086824e78f282c43973efdb1c05f500b728aa6f4b9f6ee0bf5829f65f7418c94b0ba5e475736baafa1a0e3d61d5f625bb5420a57e9fce1f2e8807db58e5504764e3792c14e4f7365d934fb7fe034486e279729e77d4e739a24e2057380b4543f72cbb44a195374daf6784fe2c863f76d99e92eb38dfd7757d480cac15d6d28a5f497215797d2cb4c007369e92f42a5e3873bb73e1c471fe28249091f7c003dca925e9ddd7fa9202f83d1facafded57a959a40f2058654c66819b7c90965d07eba8ab3c079e2645bd419f4a39c651556fd7173cba4c594ffc4e0c9a7f69ebc72bba6cd39b1734ee1899161fa3fb13b0edd1643ad40f380224a931985bfec8ce1599438a2cfa92e4de4df34a9413950fe88fcdbb29c5aec7a5ec7cf14147ac7eb4a23d278be93a1a17bb4378bbac562338c63e8c29a5718b432ea0234a22e61011dccb15ce31fc5aca83cfda223e117c27a5b7ccf9f493ace85b30758ebe232ff53f15cdb1128a1604d55f7ddb2ed429034327ef8ee4698a9186ebd273422963c53a6e302926bce0498f1baf25d0eb7553fe25a0061107eeae0c91d4f36f41b86b85bc6152b9ad300a3bffb47ca7208cc251b87ceaae6b618807b2265380e8509e5816247841fa1b1dfaca1f9dd8f2f7dbc00d7c623503c4f446c52d8c0318f5daf53c3172d4516a32128ff2b8f6588906e775031ac7cb4babf2f60a27e403f4126a86205ae4c299e90736f9a1886ccadc12930e6e90640c89789d7cea8f762732d56ea2f644fcbcf5fe8aaf827de27442884abbbb51b8b8691e2d125f0478851d6b69e7346e2968b95bc71dad21c083efc7aec1810fdee580407185368353cbd8e15ef6e5b6ab9e6cbffe87dc9679fef3f9caa63424048ba6d34e4d9ebd960e25a5c8372ba41d581ef5bf42c4787e8bd1fe509ed5df46cfbf7e92bcf330f6a23af65d812a6c98343cc6b4568f7473a39dc037acca2e77643296134f3a8e105225b296d49f04960c7e20c27891d228dfabde0547918a05660e77f2ce63a119886fa6d8590d68b46878cd3240b6c2dd9fb5006f4ddec4462ab1487e3beeb3ca6fd3faa0417c9695c5d9338aff3785dcbd4a77ea552988104dfc2ed536af767e1aacb2632631c1fa2bda3bd6aaa5284a9ce30a417fea1109efa7b4a3fac8623bdbc376e727e2c71f15ea6a2fa1a780e2470fcfe0abff398873ff33865ca4cb59b8f42b903ec828def06fc8f5f7a5cc61d315083b1c4721bf8021061c06164be0e0c409d028202f8983db06b63c1ae97470caaf7ebee44215343bbeb13640b89bc7b5b318e81c21b1ffa106bd4ff33a373c77780cfa8d9136fa831199328d7a7cfbbd749baabef799aadbbdfdbe5e7b9947411d9d1725c7681ca45f7749593bf7b6aa72b6184cbbb2e89d0c23e8c606ccdf9b51571643dc155ec5d1cb02f68d97cedb741a2cfb9220c0c376f0ef4aeb02cbc1db515fc4da4fb79fd7b22ff8b7fc54ad381d385c13b3933229453b5608704d666c257791675841d43bc3f179f5ccc01b0afb74c36b5e0b6c4242933e4f81db2016c6850847937c5ff81d24f33f381c760750b9bc05532ee00b8113061049853ffa02e6c33c8d310803688a12dad67c3661a2c92e833f80564b0e0c95e3136a03d8e55ccfd520392fdd4f68d8421ba356b6538d76cb6dd3f5ecb1dd74e54fcb3cae8d718c6694690d52dcdf03fb636435d20eb38afc07e4085a9448a787c018d381fe2d72eb05bf7d16ccbd126b60e8afc3ac1192de1fb2d92d5c76285775b98936e4144206273d7dfc7f104e67bd06b1789b6365ebc38b9607681ed7b2e1f41c388b01a63c3018f78e91d8985921469a3587233a0584c1661b86f39d752cfeccae9d2764af72e4ff113cfcf8ca636a3803b8bd8137422a18feaff840371c7fe77f1c791c7f6001b1643e1bb2842e5f02223a5dd37633b04059131caad66950127ee665ed9d82cc8ae3dc095cdd0b3cc994856c358bae89f1880328c9cb832f9f4f61e86a75cb6e1b09e282ce2b44eafa1ba69aa329d983773741cf75e95aa240f64319c3a8196ed3895acf1dccfd98dd9d7d96d9e49220f38c3185c2a32c6febd8229ffd4796cd56dc32218f7ecab4a1ce61feaa13fad290c47f3ec7df88b45be06342d588bace88705c45a2dbef5421a9d30efa1ab76bbf4a4299f336168a9230e7602c4966638aecbe8d14c11854d75ff485daf3859e08796d2663cb1260f3c7ab6de4b6f55a6b9c2f23279ba47e845a6d3aa096726ea75995bd6d905d23dea1c14ab1642efb6ffedb648e6eda9fa701e04216f883e6af0a4e100826d64844cbf235b3a488fbb8e0b47f8ddd504357d3a84017ab0f8f718c9ce5d28b6c6be90ccbd761a9a96f3da4c623aab8251a391c0c01f7351535180ba765db2a5b7b271400f29350886e750b3a665fd5a19a329104d2e9342fc0cdef46a05b00262fabee690dfe24add110f1087310c5b28c2f7e9640491d9c066f1c90fec49f7f7556a0a83878c040988e87bfaf077c5ce725caf01a23ef202d95a7496633dbab75c00a2f7d9d6ec107c47b2eab7c9315de06d45d8a55a69fa8393613f2cb8657ad79f6808bb74b3cd8e013ef545938f1c78e860cd969ce97fbc09c231684a911ae868c72ff2e97d3af0503c155cb97d837b60b925cfc01e9163c54a56b09752304dd90325b0b5e9a49cc1f8562cda0e5505c7ff7e82192d4af7128d9436d7f5e0a67ee12b3781720342729ddd6b390e78f5d1aebb9df6da10feb8a1e36e10cca63f422439575a92b2495bb89b55f45f45417265e686dc1f900d7019e1291c8b9d2646afb9415c26a9e25b1afb925f8260ba06a64b488b0d74f21dd5f57dbd5a4431f52599e559d671a44111c20ded0eeb6ff7be570d22c38b1019ac0e586e911a6147888818c28479610643cf582fcaba21a539bf8f937843be7475a5cd225a6d762ae38101336c152cd1529e23ec993c311e39c88f3062aa0942acd1449763fe3d98c180df8cc8a847d187d12f637a1c1aab3ffe6a079c357b6cc236627eaa8266d8f20b3271660bdbaacc3761dab934bd0817b016a74bd5bf0b4c6bb8524e16596524deaa95363b40b8c149c22c68f7cf24c97a890f5cd95cdcf7a93079725fe3babb7f5f18043e7e0d6d35188a7dc7393dce3ff8e4888f13021a14f3f83062791937e26afcf872da7f1439b3c625796c67c62ddf4ddc1106e160229389073f0dd9a2d07ce6d755c81bc70d9d5e060c29bb13b2d34dfb38654dff52c2b8b18be387bbbd4de619cca336d362a41e3a2f9c21df51008cb4e52276354824c2a86d15cd5fc0681c7bfe76512f34b739542fcd938ab53e4bc70336a0186ce2f10e02ee8e68a608aa51dd799ed73b3b1a35b779a7daaf620bae5897dd739ff1bde75208dabb894c9d940b6eb366cd1d6f401e26e3cc67812e49d17539c5b42315c14ba1b0fa418f1cfdd85eb77fe0f5223d59f071ae0b65d11826b7f7686ff735e3f28d472d18c11e773c567bba9f84d54b51d980936286b9707e91233160183eeca1b9661a9a22b03619f1162be4501963be17cde68d12b3b5df6d682c404c24552306898af575472db574270bf0f2b125033a6fa20aaabd23be8a14df3e38d090300ca3bbb44c41fb7f6954bef51e6c474e3cf9b96033dc1403250cfc23a4a86e0f47bc9bc4897c154e65e3b7e11177af75bd6ce9074e59000f69bbce0f2f3522d087a05647f599c041c8c857619027c6d1aa65fcb46414437ec8cd5e2ac1f69200938b5891ff4908d0561718ee215da7f13899b5e3061d946095f290b4137010d5f2eeea5c17ab1b9902b2104bd9a3504c00660ffc7d7ebccb340fa31caa5ebd47af60d5c1d1824bd47e8b6fd700ece53b7366abd152e9eda4b96f32a387ed415d564f2b965cfc8efad7273c8d7a775a7cbf738a42ef7d4538c85fe24a3dec271f0fd606910b4ba14fa7bac8ac4703ac1b8ad23863f1de0cb0e92c807cf09f794b015a71b11d1670a51659fbc9c2cce82451a51d89c8dfabd92246b82b77fd1e3d16046dded191dd7320adf9fa3b6e5fbe6cf53a2f8450c42a5ed6664e1895ea6c0920d178cb31c7d26c4ade6b05b845bbbb6c4247e8ba2844a08177a2b9aa40527266f71fd00bd14ce18341da80a8fd5b1d9598b800cb50610df92700ede971b3c7a4a470d06e1f98bacb1f392dd70791d9f874d89037cc7d5ef815a9fe8b1151f81bcafd5e4cb7aa1706c7c42b4f220b0ffc7a61db1a5075abd808acc9732f14c052b3982fc67b4e30c0a1e5f0f37b2c3adc5c75a241cf53f79f396caf4689cd8549e74a979d710a88716f11adc9706a911916dbaf44f903b7abbc3380c5f95ca06094188253214024515f832297b8ab0a07e18dafb331716e3fd4774c89cd8320d72d6ae82078982b12700b2e25a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"53471e54a56bca5551556ffb28710f8a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
