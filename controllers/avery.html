<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67d5af5cb158c1f6b5c00f4899a8f800c4791344faae1508e7f049c2ce7be640d673caa316bf57aa14e2ca55772ec770ae494bb6922f1f9fdd62233a6df7df6e338448fcf8d7a9e6bdb2032d9e0c595c596cc8a84e9a287708209234a08ecd00aeafa42f65ac0a9af269d0d0ac2ad393b9c3596e956d1570c4f2f4edf880e45fb58db5c08851c9a36b1cbf5df96e0f750f43f62347b6b73504aa61c603718632309f7f31abc56f63cf8fd427638ea2af7b57a747a6f993a1796bea5c242b0f68702695dd59ceac49a5164e4dcfafac87badbe80d88580e38004dba258a0d670e85f6814f67ab5726d19cc368af1eace5061b3b676880497e83b5403e36b2a32c83b83ff0be1bc2b9706b97bee2c830e2143e8d1bcce8c8b76923eed6aa19aedec55c7c170b9488df974c0c048bc17531b89a85585f50e7b1e3812c3aa310e30d2b83c44aec265c7a08b64781bab1ff8b39df8185dbdc5aa35aa2ec65b1a10a36dd1027bfe0b062b416cdd6f053e2a69fac795f240fcf4f29e0ba863e63a1a3f847cf99ffb5bca79f0abc1d30aaf666065750b400a0a1b853e4c5af5832e1976fe45ba8fedf04688b900fadc1636fe9b0cf91a037f76e446dbcb4629af2fe7a7eeb9aa76ca59892a707f2a3de088789c489f320611cb55a7ab7de936b1459beb51c4336a763d1b69317f81878a0ea79a97327c32c35e1fa5d2b93f9903f4e003b694efabcf240b80f6d0e0ee37e0c6202eb8b7bfb6dc7d2c403087cc06d5a0bc8d7fab8a486d4632a353f34f475928531c1bcc030473f0da32eb7a757fb4aed41fc0d311850fd9a9435f1cf4a19c19af0d1ae3f89a2ffb3bfeb72b570bde004fc4feb3869cb7e197b78ae7b916cfd68ec6da24622792cf52fba6c64c0f13b1a563ff2412ac21b03c292f7ac3a72666408f5a96eca3194ffd685376e5a5eb0ff20dbcbc87f1dd2aaf4f7e8a6fb087ff798c533d9c6b434c066762481386a90ea96acf867789bb2375767a56d81c08480c620a13eb6b447bb75207c8a400933ec606d1c371a5120a76e9810b3796a3c94777e3bcd8cd54c0feb0a20c870db29ff470448ef7719bf9c2bccbf3b9b77ac0e1f27f5fe7129cfdaa49f5461dc5c2b977a745f341d72aeb0993d716789e2976e4569bbf957093e5ee85f05ad30fa33fcac86fc5392328405222165eb5b9721775b767026ecab95136a6736f6a943c9768baa520e27893694eb975ff7b8617a98e330ec1e4c1e6d2d92fe70d65f4d557134926cbe602385dec196464fcaa8118bba6ff859d0aa8c662f02c11fa60966c7b46ca749aa6b227a1a248cdef6b4e2f989d9685d8b5aaf9f395e9391993b196cfd5edb7a41fdaaa1cabe9dd93b91eee52e3f7092e4c60facff22d2f81292beadf3305023f531bbb7780bf5721fb55314c67dbdc76ce2c0e6ae92b94bad7c15af724f8e2a65aadaf6ffcda02761cd94d9b9e6699fe546a9dd9fd94a7d51c7544c952330fed4f2f8992fe62d32a97c10b27a6baa874ec77bf6954d698d1f1ae3ff02b38e46443f3e5c3381dc9b883ed5fc3c84bcb68a455776b3fdfa7da9c977c57d4b64d2f649ca287667ab25047c79651e2731a890326bc63b255393709675c1d9f6ccb312fb17f04fa6b4a2c183023001ff65920123b99748010d748df4123b13d58bd50428e52d3fe45d1b8393270e14b99f3c07acccc034d56de48832bc52d482a69c67612b988c401f13300617ea67efde0ece8d9923ceb049a6af709da311bc55b345b46b67b39b9d1cb8d77f404295a2d789f3e403ddac3fb065e573a9e0ce173e747e0a88f6089284a3949b9a049ad9ea1aa6a1c8ef30f6ce41bd31016fce87b1f71f74ccf9dca3471f2052499c6a14a91482058a6d992ecd68cb2bb8291698e2e7d059e34782793dc198c25486612b5c52a265234d14dfb6295ab90deaa3ff67388b03c0d0888cd98d0bcae1dba6c74763acab857c8df090e8f968d0eaea02f61b7ba0ee3262b1e8eaf06cbe992768a58b21050ef99429d7c0290a70b0eed4dae9c775cb83a10814c9c0c84dc973c369cb28e5315c08ba9bd7a5f5ccb53ac839fce85857ed4fd697b3562afb03c351c78a9da116056632731154f6ca34bfa757f4d76ae005937dfb55dab4a7327f3fc05d2b45ebf1f85eb31378b37fc948e6bf66cce3181bdb48022a24935260f1011c82e618780ee287d5d63503fc6f8dd3feb5d60c1562e68dbaae49414f95ea42960741580cfdc207fda5b8976ffbd6730147c76a9a869cf6a8c052736efad52404087a4dc7b2ddb223ccdd74a5dc1ae25b65ce8bddab207530143454438d3ced4d7443872453a561763e9cd684ade5ebb01be6e05fc49fd5e8973ae306eaebe2d061a9d83b67c6cd5a6d173283fed86a8b7565c261b29a0d99009764a31a12eb8a4bc49cf0cd18490fcf088780d753c6635e9bb11d925b9b69438f4cbe74bfa1d3c83ce9c34f68e134614bc00593d7890e9d341a3c280f0e1c283d9b107b95729221b5108b25a687e8237e856cae62f1fee95372250d4fe5f37d39238bef3145a209173b3710f70fd9f5ca60c7740f9ae11797ff097c545bddebff353a637b1848ea601a521b2fba5441c31f4ac29032b2ccccde3eb7c3c35998bb4ce9ead0ad139ac80861c3e7b58322ed8adfa70b0d5e0eead236d2aae1728cc12d958daf7a5a2b894233b5b87c231a468a7a347ec450c8534c100f1793999d360535faea94c226416485f27cbc4074369aca2bb6e9fc6a5f9cc6343b36627f0f9ebcc28358068b853511767e1bd437294477a4ef0f18faa7155d3e1b42a64117691654a834bf5772f87959c260c5ccca977d332f6989db7b3a6672e79a8591cfd91f1674550353d991f150ab2985a96f2aac0d425aeecbe141fb42a2dc7692461bfd2d75043656fd50a053ce39b2ee5505fa1ddaa312fca841a5fd3a547c49248f789d7d389bfb4a0d9121a918a00f305e8a0ff4ddb871601d096b0f013ff1ced00443fa2c26423444b208319a321f2b94a3eb30aeff20b4335d14af329ef36116f2c07f2e892ec0f39b3a970d9cd7afe308affe24d6a8f3671ff1d748813712c2fbddd5b2b8a83274d48a1e4770623de7124775611d76c0b27dfc8cd3026d2dc22a7dfb270f501706b092e2e43f96b00b3301bc704c8cfaa27e25b419a1eb87ac6282b3c58be051e7b7b3185986e4233ce6ad2b70bfcbabdf1003c011d87e306517c9476e2e9bec8b22185c53f1b8b69667c8b9e16efe17b06c9bef25df3c3afa95d2b21e3bfa898edf59d08edba2d95cd1944f188da0770766945407cc0a9c349b08935a44b2dd527e09e0374f421cc9797be9a20c95636cfba52958c28c5e2d16ddbc45d872b0b83ad342d167d56114b279cf315496c082bf97a51d54de5bdb80015c8de139ac3544449130ffb1f687b482edc70aced26bef3710bbd516ee9b92a122c037f95268867f72c0f787d242d176b03ac5903309df819047f9b37c6c78227c826d17102bc00ec9469ed1bcd0ff059ed60635fa459ea8d616a77d6bdb1f99974b64be1d2434fadc54d6f42620d7eed38e66d5e9d20527892285ad65f8116edd98ac5244331ed232b6da16d5890db822fb8a523cc57a5961dae36a5e198a6f2f6c981eaabe652fe15f42433014b3a77d73ebe2a8c3828a12a081fb00495656d597dc3d4f01a76021ec1391587718b3470b4bf58632c4a4eacce87358c0ea8f723dfde03cd09364bf626d7b6a7f98c832976a6e1ef6166958da2adaaa1a5ccc2c241bd08b7221e0226ae9741b34abdf02322720403c35d684d66577f8ba83bd40d3105a32379c6920fbf01468c5408ea5ef5936297ea7bc58891fe6438b305cfe9da5f57712557dc4c5868810d0b6ac119c9bb84f16ebdc6333aa41ffe4fe427831c95ee2656abfbd1f79929a3857fc737947d0daaaf9151b61e04614f4169d609ea7dfe0e0d48688d01e0ab3db0c2d0f446bb85e1fdb82f6fc6d887bfe8bf0f3987de21c71320f73444d6c2e5abe308b2430e756fcbd23bf6df360b74913de14ef5e3d481fbe784cfb640bf97b61dacfccc2a6f881661094e1bcff191a3edb4258830b7f20d450002508c2b03d6547e6152cdff5a51cdac477d256254df13bb3306f1fa26ca3c8488897ebf0efbcd374c87036c49fe463aece89c266fc2b877257a8477c53ff7998700061e4709b1b5855bb2c7011ffb4f177248e7dfc299510d37a083fa36421fb9dee795879790c9378b93a9f60696ad51eb9f37d369fe29a0ec48e6c63ac480e8a16d26aa09141a75d5dae645f9f27186f92ba323c921ce8eb8ca6bfd25d2a6b364f6a95ad43247c507faa7d6d662c5c7ac2e6f277f50fea41ed346e2ae7634f73e63f5fd42ae502f29d70bebd7efdcbefea6c50f9c22259c3d57f11b5762456253e81616d8e0294474f0ed98695605a7f34f71b2062c5ee87e04a0b9b6e7bd83f72382fcd3950aa6af5f97033315e97adc4d08069eeca35d81c116ae2519ee98e80b9eabac55cdaba70b4620678bed0edd8922a62153ea46c49036386940f56f91d452c007e3cee0f6a268455229a0f11511677e6abf0dddeb276de81c240c9a85e5684b0bdf4db191ffdfb421f7c749683e1c0ba368ebb47f7b0d10cfeaf5b2a28117a055d54224151395aed6b9abff401a03424d9e6d47b768c3f76921ac6243f1cbfc7228529c216bd6a1c05b0bbfed66f0699724e57fdd56b839bffb979a19e8113804b7897c7e954d13a08e71129925b65156aa27b4aa1f5b0dd5874e5e6773eba8fd95a9d915c923d8b2227f69ce0b31a15f40bbed4738f499bf5f33b16ce2b52d5c096323451a52c5445e1a44ac6d7ea5fcf3c77cc01af6ff3bf25bf526d112367d20cc62bf60441977fabe29b3659cc5b2b6791f96b89e44af59826e01e857878abbca24a69eba2c977f7878c084189d2aba98e5aa8bf7a40902182ec3b2c9d75d3204a5ac37c1e37c06042e6b66b5261ddf7dc6bec3300d76a4ea70c4648121553f7af736e97c40bd9c803922433fbfd0a19a7f6a43b17f68ab55945fb9ffcea18dba2cc1aa068b5fc80977b6d9ce7a981770b15a26231ef441e5aa43d476f38c0833b7b78aaf70b4c006a27ea346e3e5e4df18de62d958e9f1d0b42f57a8f79021f52b60661d474f009bfdb4e63fe775257b71c6db22204dca4bb44922225a7fe3232a60bd2fccad0bacf6e104527c3fb2312ab8ac9f7e7ed97fad49df42e689a8ff89ddb6ede60373fa0c3d7e504cc20c9b6bc88b4566638d991ab92b38e09178e20c9d0379c44180feb1062c79cd2ea1a9354de1dc80a0352053536715e2882bc1f49ddb5ec92da995c4582b887d83e72eaec10a8465c1d462318ba29993ed356a2a2840adaa16a1c91f7ced992e1cd42bac3d944fb00aa87753192a8c8e544eb43e073a299ed2ac9b11b96e0bcdef4b294ef9f2f0dd54a32d2222a819d9f3c6d30818e7cc1d10f2ae546ef33178f8818107853e94cd1273aa27a18e731d3984108086ba854d6413fc192f4a46fd5bc62fcdfc06e14f5ce84a0bb3045d1df9691899c6d969ab56c92abffbe3abf7da0056ff9ada6a975b9815aa58a40949fde34979f5e56ce1dfd62a9db8a910eb06dc37b14953b109abff6e0fd155cd7c588f6b0d5d076c3818b2e774caa7e25b76d240570d43cd2ae6a78258ee3bae2b2a774ef05f7684330536d5f3007203d1dc13df9a420fd9f99c9705a40eed628d08a9dd055581b17dd86a20952301e5ebcf8c19ad13c3ee7eafd62b51578bf6b9f1fc642c3910cf4c65e8d34ffd86cdeb56ce432173bb156931a1d608431f304029f4aecb21c838e1070cef9ea08e5d1e887c1e33bce327ddbba5abed14c72b3b1625df6aa3ff2d17403433745e784fac4ed894006d53569e02c2faf58e6e4a70e8c6ee67b9604e4fdb4f9953d9fa251bd83571cf6ab3c78c5f11f4f57c3f5d04ab3fbd6caa36b5673c58f0eed19c669f9d8564dcda1e6c00716708cf8eddca3047b22d37cf54088479b34f7ec632a57dd1436607005604a31700b2db76011fe3a9241617522b7855a1db298d5bad477c6771eeb6e641e65e4adfed3b6b43fbc5597db816cbf97052f24c5b3102fdf4a0e89177d5dd779ea1477480d8650eb437bd94ab9d44d4f7fe05ecceb159374fc9e3806bf6f690e56958bb3be1bfd9ee2601b04373252b112237733a5e012dd098f363f6a6628b7a0e11f6ff64297eb9af69d897754e65f4f2c1f92d99d1c404e07da41e926a4beb052b2ab6138f7e5a49be088004584477826555017c3f05cc7f72e846638a1f10e24441c0ef3bb4b00e8f92b67c2f484dc28bad6391a72a49b6fa198f1db8f71f6e5a749ff3de216d58d8ca639639018c728f9f4963931b97dfeaff3bbea614562cc1ab5b295c23c75fa013a024ca5d3dafc269955ea6a544daad8ee769167d9411f443f680114317bce696141e89159ff4ff61900713ef571bfdebebc91166d101d51d3939d1ab05a136b59d6ae8ab3ea63378d21fbbf5932872bb1e4c653e0bb0a8eb87250765025b585b5b83fdc6450ed562859feacf16e792c6140a3cdbeb838dd80716c8a6746da28a4d7d4f655e4ab0923f284c77ea22010c0351cb481c33c4730b1a527d53a8dfa9356660a2e1ff38ed487b05669a817e89319a16890766c80eb5a0a2cf9b3be82a6ae860b80f50483d87ed996a45e61ff3b54dee1be2c65a770ea6cb5f7a6dd802960d13b5d920c00d3ca7e01675c9cee5fbe5e8d63fcdf8fcbaf471c1947539d115e04916ebb97e559a8182df8f878eb1ea3509de52a31eab3dc5a3aceb3f3471612ddd53857fa5ddc1c1f1ac4285e847655c5911a5cca480b95d50337ebe320b37aa61a59d4dfa8c1e8e13b0458363068295ae974c256a3ebec152f4101c671547617758cc31a2e6974dbcf032eb6bf10f24842019be15e7e95ce2636596fe3968c87c70b3c251dd99ab609ac3563df391904a6a59384199821a77ba1e26892727dd2de760470f3ebee18235afaed2705928e550c977a7cafcb23aa3c63364012d781fcad09b996b5c39212bbd4e82e20bfab5caa310fe6eb173a92eb61416cd02705066c5b2027b92dd15c6f6b89f3558ab7b4e04ef3bf71467e458385b05072e7f06fe606c302cf4d5ec95ddaa1ac39f80399acce6e5dea2a77b600202586911ee3629ecf71fb2bb515933176861c4483661264300dccef21ebb2e4519c99eb3e94a70000481d0d03598d8fabb7629bda457323ae03a39f35e138da965bdbefa5786eb45a7a2eeda58584f0e957fcf9104050b2e79e1539a4719cef7ac7dfc3bc54bc0c797e41c5a232d203d6c9a64e8621e31ec3fa13242036c758b4cd75a20ede077a582c33ea684b6b850f0260c647e370b0e4180454543348cac5afa8dcbf63bcefe1b60d55d870a0cf488de161cdcf81e03551864be58cf4b34c49dfc5e37cd960737c31f99aace327fe6d28c78bf07dd4c302c034ad6c8e5e2b0b4a102576f902837a41dec53c86d5945cdebf3b6e5b6d90b59561f291881d7baf8375916cc176afb2dd8b32c5e20b2372ca79d51c574dfcb0ab3e29492a8e09b84449a8c5a8b920c2f538fc3f8fd501630eaa678e386387a351161454316fb3ceb0cde9f1fb0db6d696cf8eb6291b0f3e9e0f927962ab49aa0b4949825e6f00a40eed477206e7def1139e0eee75770d30780b61a10f9bdc4e8d54a27016b961cdb640444ab9d80dc76be6a629b202185f2a6cd6bc38c79272911d4f5fa9c658e2b87f4bad3196951ca593630bd8f39fefad1c90e0fc3f6c37a774e851e5e13978b652cc248d744938a4089be1cc306a9d8d98e09c1d420ec4f916317f3fc8817edae0ba6506c3cd98a194630be4e7e8ca58397e7f7d10946486ca09527a3284f040ce06526dc7c25ac9d3817a8f43bfdf4fe09309cb1a559480b5dd7aee58d6f79a8380f5543c62b2300925d89a43610fa850fcf8dc26efbfbe46f50cf3528a0643883848333ee713efc9a74f5f909ac57b48ba2a09cf15b1316f343c0cc4a1df506c726c3f108caaeae46f7ee32a838ae3026caf92befcc478ac0964f2153048db384a34feb4aac0491ff26e67b95939026c8f51761747ce372504b1343d84db6020f3b75c28027452a5ddcb87ed67ca9dd267e3478d672351ee1941e1d3fde194811ea87a83b3fecd06999e41ca009d772a649063db56cd9fd6436c123f68cd44985d55e0d3d923beaf55751e0aa694ae5aecd2f7ba1a420d549a9fafa85a4a71badfaa4c28312aa8d5d05883bffbf9712cc1cd59965106d6c9b5ff9611d2353832a638fc65dc43b110c3a36c301255ef803f29592827505b0be7cddc97b4cff5989ebad07fa70882baac8c3a5f59e31f144ba09d3cacb3850e898d7465f737eeb94bfb3e244b0db4a2d3437210f6f0df4e0789e765a3f1d110a609998a6934a144dcdd45bc7ee9326f1199aa0c2e343db9bd2a1e7375af9c41594a0ca5678770b104f9d80b4558732888f6d06631cadc9938f89ef398994ee834fa26321429cd5349d1e1dece5b884324e747ec241019b6a81c754b291570d10fbae362fe501b10eb27afa10ff5263dc5fb879ee24080a28e0c5951b86aa2d0955c22f3496479f40ed71281237f27daf33674ccd05b8b0e0e1fab80f5df0ea19fc6268671667c9e9e2945bc739bcff33dfc14e0679e3556ee9b4992d43d1f4efce3b4eb400d30e4899dce1289cd3cd3f43b4190367062e3d984c98d79249cac09e5ea10291c7ecdbd357f8ab176e62b173da9290f6a22aa4c29d081a66f593696b922ea5b21ca3a087acd3cebb1069fc33f8ec33aa792e07968b80590dbecd438575779132d78f40ef5fb865901b38182c5d114be8e7a190a762f7f7c92367a1f12c04e8f79939c798d1e113f42ce9760f5fe030010b10953e8fc44d451d622843c12b91af0889e53e253b33ab31bf2fb5f459053a9d1cef554ce6cd2daf35fcca1bb62f7725e29dc4a997ad876f35eb40a47837f90debbd26d5f904649792ba566a8776705922b249699019d9915a3dd06cb79dbdee41234f78ed85b3a0288b981d333330ab9f53380e3e052879a0602da472e50492b4506a4d2e24765ea22a17a2c445e1c9724d929a4c8cd9d5bfa0124ef389ce9c110993c17a43fd8f8761f0aa05b2d0286d6ea4ec1fc6a17d28a2bbcbe15535176e0ce8276446d90b5a1d7e77d524d6a11c8005208b453c41ffe891c3f7bfb31b99006759192245918fb449e4d945d0ff10f3417819f3d1e1bd3e2b906e5b9faf312729fc16d7547c00725ed3b48f30829a51539058f9f44cf95a8a4fc91b72bd00e797b6565c3b475c3eb737ddfdf019017dc602a6fff6757649cc48deda7b634159fff347847c2859bfbbd32f8a9d7de500801bf9c30200d8671b23659bb2c506e19c55ef82f5dc4d77e976b95b7c8e1360a80b1b1d62c47dcaaea5a9ef9ad056fb74c05846830eec99e1402c23ece8040b6714d29a374ad75644e335f76d701adc247bd301b28c27f413cff9eff757cace3f67d90b0d1672c2170a142c2510de8185ddf2e5cf4448733c58c6d5aaec03f0f29e5b9e8c0e15ae2704d474b1a7578a7d3b0bb9014f797920ad5cc345181e1746624c1f27e6a97c9bfa0aa8f96c48c89d5be54c8a8834edd23653c546d27b247f7cbb6dcbba3379b9463fcfb4cd8d564f6dd748008ed95a30a04d466a9ebe90686773167889ed6ce19c7ce8b5936438ccee5edc06b6c007723cd240e1c8f8032f5698e36b3b52209bafb5edf78e65a264449b0f6ba36bb153652e957fb516ee02d529a35fa142367bcb1f7bfece879da691dd38440c784b304a5afc4de85d086a39483230d352d61af05803591a659a16c95a762ac0bda358ea65d67c5d6e4101cec81a1001e931af0e607b23321e5a0e33a20716ab8a758d73bf46bd0704b8b2ffbee9bcee92231ab1e95763521c2d0cf6cf8ab80ade7d0803f3330160a0a13983ab48dbaccd3a117dcc7ab34960e99473849e5229742508f0cff45a4db97a13720cf25ce8fc220107274de1dbb12d589a7c51204f3fc133369d87213d872ec38467b7a12d409690fe14d9e5d770cb5e0b497a3cc8153414df12092e7cad97398ef64026253bb42ce8b1a0029925bb6465ac7b0a91af78845fcfa3db40e17bd733a1357f0bf3ca3b0aad07ea33eb917431c8198fb611a180cb084ec9eeafef9a645b66f0522d5a130fd518e5ce135020aea7637091914844af50531b51ce3fe619eb8149f4209685e8addfda23662f1b8ea52b21e91656f27295bd385df6b3e2822334f5c86ed352d06600f538c77fb2c689124f1f165ebfdcc04e740e8cf645fddc17c5dc9584c9b4d19c0b93f312a684d0a8bb979cd907eeb47ca3161f1410e7c44d4306d7ec6b7540465a485e290c44ac268ff02facf7ae009e8703dfeebaf07c336e7824517dfa4a72f57419f61dd77138a261776812194168ebd7b75a8568099818cdd077dda1e8d58ce850ff39dc3e281ba71a6f8aebc99944e2166f8bacdf8a9588dd3c6c06ab2c1cdf121226f16855d38dbbcfab6ddd55ff5399dbcac0e58d2b6020bf952841b66a85c4fa315276e56df08a5281e348f08b89d8be2e149a450c69c3a17c88ccdc031518aa6391d9c6fefc0f790c47096c28a35f49093bf4130823a19f0d09fe8621bf8b5b205a4779fe8278dbff7377e5efe9c93b2da2aefa643996b8d93fe2925b4104d0f1a9c6b7154b26cff7746e98f4e95b03378ca3b24f25fa33d5033de1717b371940dab0ab84685822a4f9256ab38258e17f39c1f3df7ab1713eb0b7c5218d1b7c40605aa84f75d92fab0c5a83def9358255f74eb27bc74e94ad783de8bb582782c684cfd57a823ba53ce31d2d43d21e9cce53bfbaaff8166d4c78b9785837dd94b9bbce0c9285b8b3830f9ddd9901df6337e4124fab3d99a4bf5c231fe59374da592ea88a4f220fcddc0a7a93b33d62bee2c4e5cf290ce3d796dc89a4e66b27e67df174e9b11a6807c9a315f429edf34d71b2ded530bd806fca4c9676803a56748c01bf99258c61c8cfca0c0f84c96085bdc128b68b710d9976c977c43c408ef60b8b2963f5fd6d3a13de92a6cdb4b4fa9a92d82ac0274b466259132340a801146b6d6424842fe7f1654f3fffb3741bfecd14b5bd46e0fa82ebabe6114d181822c8094d66813d47b907876899894029c6790879f03f8c6d2d45b08d47131d295d18bf594952d3a9eecc97112671c0e34468bd46c91f636559f386876f89c8915b2da5ab20d455d996d4484cecb61c68e9a95246e64fd1a67545ba719330fff42673b9b76c8d21a4b45673557d1701c9530983c6299b6d86fcc8d9915c307868e6a156e9f3aeac7d752975b24f77c93d824022b65021c6e36e7ed50107f29072eb509a851930eaae60c8ff27362b70f648373eeae4db6a1824ad756127992289423bde52e897dfefd6318bb665845cdd51a0adb8205605245cad04a9f207e2867f8233f4a65a54467a6515e79c29e25909596defa32ea283c444f3f9a3ec3e15f5df353fdbc080f8922fd234965110b6fc354d133ee8bf2a1c724293b54329e119b6d34ed5af607434a043277ee4da5f937d4f4828392fa82e4b9ef547249bd7b3afd06e439d909ac49626c446c39485a4f55d903bf84f645db4622cf52cc9c0eaf2d1b60914ec6f342c782384859761fac03cee34a7c041db57f8ecf14eef0888a065567c019859096b4207be4f5fb72e9edb447dca7471149fcb66ed2cc904e83ed4bb66e9e64be6343600908c3994f7c30ca3c186ef77996045386e7b1d6e468650c7923a6cef13c81674850a5387c9ae7655c637e0a13551facc9401031999afa903410f013702d724b5262dd54ebf3e2accc0d275c77715ca7bb9969368a5f5e297725eeb95ea2b77c3a62df99918c926f5b0590cdb99544a8ea5be14a81482fec6d795f8206119dcf6533c9dcc9a83c3b90a35f7394f96bb8cab119d8d935619b8d1012f8b8d38c17442259e0547fdc0bff998a9b9687475f84c7040d26ada110a90980459c66098f2c9c1d5cfd99a506bda4bb093d06f8c903a7076d6a18cda21225df7a2c354ec1a300627b495119cf313635f30a006ad12cd20710346a744717ec0d953570769594d37bc4a41f100ed9248bce2435bdd2342c71d5b419e62d648f8aceb1ca0947358b1df6137b43081a0d288399b2df3d1d91b411338dc9f79ea6a797ede2c9704053c0d3aa3d558cf46d3246801904167ee930ae4daf1c029377146fcf5e9ba087cc58104bd3b71e56837bf6715a29637bb3a6cd1f1345d7bb115e46489439cb6efe1e9eb8aac2b9e09cd83d63f613e313e76e8cbfd277da358c8da106236e9746549530f5cedd03cb57f90f98afacba05be6985ea64312ebcd39a8f5a7e8c1a50ee33ac6991f1d04f1d3965db128b05525330f6fa753e64efd0546f058e293c58814e9499d52e82f100277564dc554658a2d24981c4bb5f80e00a3caaba9e073c9ae0636c10b5604781a616db7fa243f60aaf6a8f61d32f414451d2a7a93edcb0956e79e7177dc66f5be9215190ec97e2a08282fac2d2108122845cd665728ecc96043c5b04d6e4e2a90b2564d61d03e77080388a70b383dbc0ce05dd15869b8cb7655bc20f15522334dd84ff3d2e736241cca932778b82bb3e43232b84de8ee30920c1bc1258f49efe25d0248fe2f106f13f69991b08eae0a49771a39cc13cd0c259880398b4b8b4a2fc181a744e1bff97ac188b26626ad50489c3d6d5e24aa23bba14dc9312f2de9e5109b2bd9210cac1a5e5a19defb0d9e4fed4036d660861d6c74bb0faefe53e52212dc5d7858b07e2b145418181f59356f4b2e9b24ae24e8881f717f6037e0b404f79263ce4f6bf994db083e5d3037b12f45649c39e4f8cf8a8a74df3cccda004cea83c675868e37d3c256892bbf17b231ad8068f9697a7bbfbf75d5559a2b25fb1a1f9316daa7fd9bc212cf449bae4d4fd6aca62e194b16c20d9e4a2e3fda16ceeda6aeac09ad63326275ca56296f21f486e40ee449560aab02c0da3f244b1c67aaa15126d055a875476e792bf331ece59e9dee0ac789b6ce5850804fe3d48806a3646f06cd3b816ec39c7e9a1004cc42895d258ae739b6d336567b4228ef73cbd243195b0d3ba9625131c4d9d589ad040a86df97fddec5b87e4c0dbdd49dfef0df8386eb710927b694fdfd8eda76cf84beda8e71ca474c5b276121a93b88d8533641dbf90d7f31b0be32979547fc3f0dd6339728d410ca6469b402e7745bbcebc56a643fceb01ed4496f383516bb5dec8e4f8b52b8c465a9fd4f474c7f62a24492a783dab2d37b3ba32a1f0591c7aa97ace49ca60be29c9dcf3554c93a1065e2905907e4b513e45f6fb2f2907d03c85ef4b8cffc155e6f1cb7e3b4b531c109f2572c06417625a92d807c9f10dbf7150bceb11654602dc570b37f14f181e0600368fd89e7e33db5286dfcd79a4ee8ad84638758696a843f05eb0791cac504f192211a934d9c1051187120a1f7a94f04a33c038212c63741527d48a01d56b430dea6667f5e02d6fa486161c1c3730bc054bb4bde222d5227f7867786ca5899a20c6d61a116be5d7bdbff0df3424836ce5dd6e2e81a25f1e2180a21ca59b6dda727ac7d794fff62d640f7778e8cd4126f7f688b944c0f4cdb0ba2958fe7c1f96274e26c82bde21d559ea05b9cb4dbbb9a8fc9c0f57739ab39f43706ee2c2e526745e2c57f79daa915ae70c1ce5d9f94ee274ab44d6dc11a36bb4e46be2a66d9ba80c88f31d479e2ec231d0c9e891b37f7df9f1491a5903d9c9a1fac12ca77b5c544225db41bb7d11cc40674ce09a4b942876c95bf2e95b0d10e19dbfa53abeb1bee27e3386ec520dd7ba2edb5a63536cd92e3f2642ce1e2dd3c574e3f1dd62be1a6a4e9cbf439d6c9a0a6a3ddc5e623962e7ac86285de4a43ee08123a9c5b641566d6a8d2502f6bf24f120314a3d9a6b40fbacd1ea1a5f6876ad78f8ae83e88c7d7d4fa8ea7649326020bc9d367f99fdac6c2c1b82d5df19f0618033abcb2cb67e2553cb76cb52ad15834369d02e4b8aba6dbe406fc1014bfe0abfc016eaddb3ab73c326417f17e58ddc5a42d854f17e9dcd70e6d85db2a0780ab9a4f331b99e564648aacf2e7e681eeb4dc66c303789b3f6a8977624e1104d8a30483fad77528c3dac35c463a8ac85ffbe27a7e5e01ebe58ab8e74c97260af24ae8838148d9f25498b1c31922aa6600ab99442d00545cdecde95b8f800603260640673ec43864fa48c659f865fa7ab6f7e9e69d95ed558078207886d6b3cbca8e92848a6c5dd53192d3374f2af1ecee75025be672af2091628b44a9e583885b73cbc488202ca2a8bddd4ddd46f90ce2f47629b7bfdda29b5e135712b6ad4c11c9303ac038c62c732f1ea30e324c6734637e2490565395feb77cdae23707b1838728a9a6e77a4c08fa516546e73b861d8cb65eae3081187d7475e8bafa14b72473e1a688b5a1ce34867d43ae90daef19ff20ad69f55a86864daf8d9e67cc7bebbb7b1b3a916c68616b419c3395821fc62848721cca9384ad366649d96dc0077073519a2501dd26b1946a7fe5aa2f19f5869f68b02be9d5465afa2f16a49f159ebcde7765be2964d68c35c3201344c00db259dcf06c3f02699565424b899073c97e33ad18bb55e3d7afede940579f0025ed08717bfe6d70c42b52a2e44853eab88daf1aeeb833c5eff0abad7c9d5bddb18e1956840d9d809712ade8eff6c68fed5db5baca909cd1eb242b67b96dd504cee32df6abe0973d7b3483d64ec88d633d8c6aebf8afd327d1d74ce9802b63fe4de90c2217bc194c229bef6ae898059a25aab132414a44120971159f79452ff80090fcca804acce4300e1c9147986bcacf6fe18635b1f049e8619f42364beed9523c2273d87f6e368d13e69ae5272d5b67a694d31fa594e7a121a468b078e80bee49a9d36076cc6cfcb443124f0088ef26f13d732af2844301ff7a5ec641d10e8d80718b62ab73a095c7942fa158ce9b2f8f593c5492cddc0f6f4966bdcfb0f56944965123ab62f065855bfff0ac85eb5a912cf39dd2850207bbea9932a19853ab8a1677f46466df567813cce4026db63931fcf0d6205f69a3f647cfca3381474e774236c7fc0605e2c4158fde8df3e94145204ede9f7de33153907b184d5e0869ff3bf2fd81b2338440aa8649a6500cf00943284aa7d948fccd1d17bf57cbfe26fbe69f17c74c2cea6bf9557911cd03c50791234a3ec9517e4003e0d5dc1c385582bb3a25dfbf95229d64632835f1c4cc7e31dd0202b1422ae5f3de755c56a64197debe2910cb2db1aea708bb6cd176063e5046901617f748e6b766944c35988ef282cf5977570edfa1e3a684473b106f1b1d6981e31ee3651a370e4e6c0f08457ed28630e1ac82e84d7f91913983c12b138de4e087ecd8654dbea4f7443c91f8a9d013296681998d7c6ed9aceb14cfa0212d2d7127c744f24362e117430f457b01f09e7f58e95a1d9f92b13ddaba801066b22e16d2d629d377fcd8a08a2f353cb232f6fc2283810d0a957942a54b8addc011deb00b30ced02191eabbcb703e670be55ab8c317f59ff4568cf53bdf408096a341a29c9a89268aba59fbf0c48dfbffe7aeba22c8f8087604086e0ddc1ff65726690f274fc2bb0b9395f01e61c91f4e6f1ad2162cc7cd2aee26c49ba0bbacd9321778686e34edbf874800aecaec9d171606f7ec1012c169b1fc16b6a86adc7f9e0ffa2278175d829be3babde7fb49f8187d125d4144ce761ccd9ba66e70e532cf2b61a33933c698377c91e5a07df6d425cb8cdfbc24f7db60ba25c69705fd28ae121a0a826eeae0dadf43e3ce27486984af3be7874bcf474a96f603e416325fd14ee8bdf577cf23a9c62b8cb1f36fa6a60ef0ea3b02344e20329700e85ec0970f8d9c7f588ff853804873cf7db2953b3a9ff55861da8875df17da4ba5010bd1667e2b9a3daecc01e0ea92321e10e7f8ba442039e2af8e6364e438809358742d50190dad9763cf667f98a715aa9ff8a345c0d6eac41bbfc9e7c516e0e1985199f8a9f86db47883a05f7d22af112380f05d2dcf30a101fdcd3a5ee0838e5fc5580761711e01acd58d97633b1ec6460f51f774dc889dec6fe116cf573f441d952f13ee194163090649fd9b0d7fe042bc447b3d79344993685a2585a7c9957b23ce9d3add6bf42b3f801f916f6f9b9e49aa798d223933b2fb97b680134a4157677d4151a717a8b9faf20eeec0f1a1d1e2e818a7608f15e2c362304e388ace01cc0ad68b27282f6e4a395ecd05f57cab378f57c4e36827e62a44776426bc5e66c430cf16336ad3b72a5050c617877c90ecd1cb0127ecb864b444456263146f48c55ac001b18b6bac93e7a90ab1962b486c53e0c1fd496e85bf4a8d829173bd811e382010c98ce5956f469251dbca4fb60dc6eebe8842f89aa91cb86a47a4c8f9f8194633ae668e6fe9387f9ea1876e72bc79e5ab07f7e019ff3bcbdcf821445a55ebf583619b452bd1f27445af36e612e34b58a736b82144b12adc0c457d0853396af83ff47e3ddf23c5f9b0dcd7b9979129c133a94567209f58a7270a6cd2e5b3a56d90cfda721348e7976a861cf7d49e04e78858fbc35d07476635c86f301f88e2e9a71e3d228b21360012859bf08db2e03b2bf83aacc2dae500475979f33af83ad83219fe059670ce70ea5e59fc01cba85effea91bffe280ad979cb031c6df33174b8ac0edb19dcaa243a1940602da0354af902dd54d3fc52a58b9d26b53aa1021fe3a0dc4a81ebd7c595136e2ef116ba831330d0f7c55906462905e71eb9c5be6806132b1b864954128e6d468ce1a9c8243cd0cd38da7bdd0cd1f7ed12257ccbd4eb4e9bdc74b0b8175b13b7cf9ea98778c4b0514c2b424eb5cf44b79dee9c91ef5a68093b4266849a373a1e793565d8b0612168ee20f2cbf33c06eb537b6a67f7092a811160ff39517e5a99bf1c6f1464dcf390744b655495bc39a9a6ea7082f6bb92ef074c24f5154eb91da23330fa557beed3c7bd99297190cb9f84efb2e00e9c238b53c196247b12d40c86a9ed215f92e9361c4d7f119971e148c3f29f24f4e3ed7a396f83208775dd20cd3d747131c3b215b5c675ebd110a3f79330416fa2da8c731a4316fa2dc96b3f3f6619212b8922f8f780f7f2133a6569ef96a9c711af3a3f96be010d02a8771977fc4dff73a48512bb10538ed77d9f3f3625bd023d3b0aa703001013865e4bcf9d6e7b92bfa3db0a4f4bdfd74e1a63b94be129ab63f7b5f4175c3be4f5f7bd8a061b97ab3997c9d3352b7c633cc4368433dbd9c9c3cfed7593eb34067be4546906dd2fb26a386456ed9c48b380347eb2020765107edd614b94a65436c0a4fb8d615ba5d161fd8f20f92a3023895e387071b21d121835115efa560963d1d2d96ac6a6cbdfc07fa9186ab43e46c04228cebe1f705116dc7a3e93258080bda2257a8636efc0df58238ab8ea145592331dc54bfa3409a9a3551415efa566756a482dcfd67d54c35fb3ecb977d3fd0421f10ff55a79e5db9570866f687c485008ae20d2c337da28b68e06e833a164f01916b813a767553b3be5ec80eb7f8b2b889af83971ab0582bddb40be5395d70654f141bfca7127b668f0cce84660b9246b88d9cddd8021b2161f020d4fa11b9f9ecb89a98baf7c9571b7abdefe81ef26936eb9c83468c54a5e490d8782113e634e6cf3325749a4a3384c652e3cd8900fc091b8f52ef1e835be90d5ee3d97566976698f670eb02545de3c62f4c40e4c90af564ba372a8969c2709310ec41f4b5eb058732672bffd564f81575d1ef2dad4332081cdbbe409d30be10d899897d72d40e2a5602e3a62d8a873350801d0a4834dd9d34aeb63acf5fbad6f2a1f0a9c2364ee4ad038ab7b328575d21edf9ec819f539327b0b00748095702f77e1bfd74da06b73964546fc16391cb7f0cb5c5cdbd240d56c8e2d5d8c7cd0151a8a65b2ad76e9312b515d6367e1a8b75ae8ca96cb8fa4c744af7f5fb6d4b6e8aab0eecbbacfbd906441d7558de33668d58e653754a505543cd284251d18ed7ef72e120761a9920c533d30c816f288d4f3e93b955f9f92255e4d0d1901aad07087ec7fab3396a33e9d32e0efc8caa2d79fa4f632ccefd76904b147f285ef95b9cf56be96f04cabfbf31783e2a2eb27cb073097992845e727a4ab431a0593493fa89df15c7175d146560976c061711e502b5624d045639c1e3fa33bc80119303412addf4518f0d9065df74bdbb14ca0c1f1b025c14a022aa62ad715c74e99e18dc581f2c715a3439ee4f94b9e87928edf06dcb805437e92353255cc59c4a214db25203d0377b269707a701f7b653444156d3f3f20a40510498c8662789f67061ec5ea79ab6e147165c3e712c1a8630e6e1112bc8162b179c10391cecbcc7677563d5fba3c77f31d348cf37f97459a9ad65ec81add20674d2330f7088670a2c8c6870361212f852200fa50d20acdc10b12ac7113b104228e21cb148439649ef05fb2d57cb8d5d704159ef0b74ff46d241ef37457f6ceb187d262735e8e887f2a261e7615ad55a32aa5929de2ca9db83bb276c22db8919800fd198b541410b4f1c7e202eec0edbbe45261a46d1a3fc376a9750c5c493415a9ef2e7daa4e2b7a5d7be243b52266298cca5223f02a0734c7714e3347b70e1181e018d00ce3f4dc322ef2bd06be2f18e5456e12b446eb20c9d7ae07cb417ebdc7d77b60d7ee4aed0004f32a98046d96222430fb81a974d1f497806f3e3d0cae89602ff9329ad94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ae75b25b6311a48290d232f3305fe89f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
