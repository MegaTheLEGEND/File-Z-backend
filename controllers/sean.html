<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5466cfe1d1cfdff43e72b6a38478aa7063703e2915798ea6fd34907bc5c119626dbddf068a4f7e740a3435476f7bc605ea567d65224dd672a5907a92ed5629b6048456c3fcc36e8a4bccd638deefb89bcaf7b195c037195bc41b28e15c6476468274e9d597daf9e39ab4e7c54a6e0b86c9055454c511599a502fcd2de1686c2ca36e9a2ea8e7e60d80aee61f860aee3577f209af9cede59ae75eaa9ed26597d417a29af6d5997f395f1e26a05af1302e3ccea24035f50e3c11d61687bd4ef1cc4067f505b0b8c7d638f6fe77cbd87b763c9fad2fd925640a4a9d835e31e95e970901f2a3aaca354db7730525784bf16eefee1aeaa389ab773e6fb815c1b3d44ad615da083bd753d070e840c616da88a311bd30b9a9c5ef9fee4a6c3d2ddaae7c4ae71523184b245e6e80452872ad685396dbe10de518645703f33e4b151024cc52e978b65b7faa493ca19c06a6e234cd520c5d8c7685ca0b162f1ae60498258a1be58636de2ed783d73213bf5d204fdc3d098766cb108ef77a39e5d1e54133c02cdd5739dd92e031281b68cfd8e65bb2ed2a5e753c1c1e0fe4a323d1fc9b3985e5e0ce205c881b4b336f310ed6fd23529787759b928de5563ddc9a8ed0fad623cc6fcd0086dca43a89b6b3b7017c410e6f30ca145a10db5efdafa5d84625c25b8d1a4681c899f3bb28f6939e4066bfd29188ef11fd63934d807f128a52e3572216ef37a88c6445ea811bc767bf7054f5244d0a65c39fbb83409c120ef4ef599e116314fe99e31fd14156519881e43c34df06209f0cfc3b8dcfa4cd7e93d906e7ae9d27499df0d632988c30f795f6713486acd3efea987611a4f4cacd64f5b1b49ce075038eabf3ca37cdff850b6e1f39a8622c1d5b6c519266c71c5190ad9bd29e28d69d917e5ebe0e332b8e71c7a2af100e89584e5c0ee52fd30326da62aa39e29ecef0bcb57dd321d9ff8f3d927247e70971783fba74d5128f3581f5310fc82db301236945860178973cfa808e2676e1415b25b89b51f883101bd58e8b3b63ed72fa4f2480c3ee49873f876c7b40a8e569570cf769fe0fbe1ab073921a9e117e00655c87fd8d6151c01ec478c3f9cb57d21e1736c55c66a34fc21f14d42ba5a47e3c25cfc25788c3ccf1ecfedc6d9f16d26656826868984c56135291de1d24e7a07ac79f767b8d4c33b1ba2256867fc71fb47ccc013879044903c052b328f53d5bdcf1fe9484f4b47b9a20bdf7a0b5dd788d142017962a1915e3aa2b49fc267aebc481ac7cbd42947e3ac10b563a9ebf6116ab37c0ba8ed950bbd13af8f591773c996b0c77048032fc13102358463925533576467c8b724358e600fe8605d0b59cdc5fd0e6b9187216ff40ad450334db0b2df7a7f5c9bc69f6545b901ef3b0d094302764bbea8aac120d40bcba018861aaa2949f78d43214a352be6540b411fccebdf34d7d6d8d30c4d5c0f39dfc0fa827cf132fe4183fc0dc3f568f9c375bde68d9f5cbd283d304a427428e4c58fbc98ea8563511b16aea6adc05ea09ea027793c15048213924172fd4f01489aa1f5010cba303fe8080e1990e0ed5895d5ae62ec23c7d62f0ed777c41501de87c69213a0fec23ac5365e9aedd2776f86dfc226bab90e35aba34c5b6fdf0ef5407c95e1192e55a6fa8b9ef4262817815f59c3b7e89a90609e8a7d5296e2c0a6f0fedd0cbe1e9806de8d0bdd37b9f9f79ebe95b960dcabd56dcd9a4b8301c2addb9cabfddec9c62408062abef6a44300460288e1ab2d3cb050419b0fb8152fc38fe41ca795a8e61b29399f63921bb3816b34266b678038ac7be15573e83315f7f6687787729d80d5aa03a980416323442d523d511dbdbef06649bbb8bd59a61a0d0a285c5c905b120e4187b64e6c45180892833fc186f7b714b6cbf7c4113176d6ee0d762945b5ad8e96b861c01de21605fb412a202c687e417477e0fbc0ae74afa9c20272b7668cfa8241e1c6e46824a2de9e0b9aefbaa39eb2863bc88a562697bad324470ff102545318807062b470e756faeffe661e5be3da4b68ede0c8977ab15fc9583659727f949dc606ba4fc8b79196d8bcc1a7f1ded7752aceea5048d12cd5e6f99f436df720e5d77db4373a5032e84894ed92c9cfc299745865c824dd8e5e12cc0f20ac85f73a0de5c035a48da011939cdd8641056ec4f782d950df0f57dee8e1dc348a62264f6049f02760315e54db61d20df0bb9d3458e2684eee5e0f1d2fc36d0f5f0576b35f7c1518aa9fe95943ba0a246bab181fccf2da02ad626bfd16384a8bd2a363c48e621cbfb5fbaff57f182792388757090c5f9caf6f8da514ecebbae5ae0ea5af83368dd186afd26776353dc3aca1365ccfdaabe67f27d8e280cb85b55249602d2d368dfdb3a04b059130c3743ec1e34119e7006ed70327a39ac9d4a2e733af99e627fcb2c8bc89e262b5d15ec6b7eb68d3d1e4526504341c3b39167425af7cfc4eecd1c65e05b735774ac6b17ecc3d90089b2205b4becf864ae596a05a19a24951f1a550282cb785cfd05a09f6def752cced5c30c3240a6418bf9a4fcabef749114b1cca6f767c2fcf3efc6f8a1ccc245d5d4d8a99434bb09820cc368b42abde1807659cf46ad3b045b878106e307e3b67c1f9a00d4acdf4b7476878b9f4b5857c56d52b43b67af4a10bb6c140cd7a58f2a53c5cb5894b6db9c6ba00d98615eb4443839669ba715c10447e01319257fc7326079b8bbfd14db3671fedb92827f08a9fd77459237390cee6f2b71ef47f042440a5376e36365e471b64b0e45e060a97c63f3000619a887f0ae9c4a952241dca9b357a0c2a7c6973cc2fe9b32f95c5d0e44e2381c5de2e67b7b5c36e86c4620a441d5ee46be5ddf3255baaa575d3885438bb33eae7118e3e912f688ccb21f3837fd5c296bcc3439db6fcb3e89d1d8cd4eed5ea9c6f4a8829c8337895e7ba64815174757cf9f19a47e64b28fccbe7a404200645c695fd72f2d5be676d07c74cf28b181a46d67ca82867d76a98604807468122f5c75f77856354b81274efffcb80c7dadc71f438a2184cfafe4ad20fbb93a694bf97a16751f7936b6fdb8bb1d39b0152df328246474d0fd6e4686fc1e3114b602870738dddef4838d6c3a6cc2860d33b53ecacda7256bee6a7e93f68bd4269e62cad23acb9b708123e9071692021ef9c0ac425a3a605bc1868556575e50d4d4c90f2811cc3e52d3a413e5ae36c77bda177efc3a3dc00946724b10e13b2e62369057f094a5f5d2b59bb6abe7dd007ba0e39896728f183c35ecd9702b7ab9ce6b7ad89d60041d704467a7c7ccc5163f2bf4bee81c11764964b4574842507e300cfc6a4fce53473a4a7519697e7087941d10f65e8b21917bbeb9713b6a9e8bc8aa29f5d80a60c2fc7bf3985d62492f17da80c56ff02b7fdae03e4e8609ea3a684495febc176398b68f5c4f0064392a075631b81f5e7359c1faf07d943dddac7e376c2e9c2082c491ed494309a10602af660322a700dc9faf473db185874fa1a936b3b1581f248abf1888d92623eecc783a60ed8724c2a9eed4af1de51f03edffd800935d0aa48e47d837fbd7887e7d778c3e8f36627312bc75a943f15741db35f449e8196dae6859ee69d3534628efd7507fa8020bfa3c6777c045810cc461cbd4df58efb7812c1e98107b021a30ea1692d37bb58f02db2c41817e7c43eeb1a1ba795e384474f77b6b692bea7ef43eccbc7593e7f2997a4add2adf51509dab88f9bacb227695441937f8d7396fac02ce46f5d88cf5c0f620d2d0abfcc16d1a672a5584ae76abbc9bd33e8f38b340a521ab6875951594cf911efc73a4b1cb24967877df22866965b810cc1793fc1d8acd0418c6e24146194803489f38555349b19b8263b34b6f86d147579b935910d19dbf93a547d03c7319926f16939fb3aedd3e399394ab17e5838b12969f3592d288a7bbd0ce22a693509a823848f93ae12de124dbab0467df8d0bb9ab8e146e0ace5422825714782c00170effd1c83cf8369197430956395a805cfc33f0b4d1afcb5eb680ce05b48cb382f87bc211c1ec00570b14488dca76c8101d5e9f88ca74896368cb5a752cf68b58500f30886e68e37190a6625773792d03c0c7fdf02e00d7dc077fa6707aacfbe0c61e504cda6240387c90e04c21290ca0574fc9208b24e6e75dd5b69f7ab614030c180b20db146917e7917add17d7ae837b11e87a398c1b7250ebc1d8224964df101059652fbd4fd35cf0ec910cf65c496078272a1b0d05e42a47b72dc60ad28218b4b36f09ca92bf32af4540c7ff45f2c0ea0d569e8bd356af8f320fc04c09bcb46c9db99d274c0f5df8371a9e9ce391bcae1b4e1e22b7ed2fee02d0abd4523a43cb7612a565656453b94edf8209d8fa1a671ef08eb362ebe6519bffb5fd57a0819305d9405b1b7fe4657245e10c58c72b9c62a614787e13f3918b77d09c1a71fa7d3043549d4b5abbda1c1e79f731a219b9c659dcf355d87cc17d82ffa0de0b0285963153fded058a7d16962feff1bbf87a6cc2757d028827d9f9d9fec21666756111a055bffca0323644418ad66dcdb0933d9c99fc4214cde3535fd65125d7ab29b759f98fb427d83af293c97b204d7cd0f5457a30c8c2b1c17c8075be2d4122b03deb48c6cc10e7f6a47cec4a153c0683542e9a246dbb1c776895c81d2d1ede15b7828b9a0252ae08df47dfefd64773301e964cc118b8009ecbcd5c434e3fc7a20af618ea0c0a8d51a55804078d9dace993a803e5b6595a09cf663a27f366670a72af464283140e75b360de47093bcfa511eb7d8dab63d9783d5a82c857b171a1f8ce1766d7e3464ba7cdfac41ef00d39ffe4bcf643d6136304df8001aba7b8db9e5512c1eff4046c11502d1c41cc0a392cf71d0e6069a98d75c5a6941cb6768b066707a92ad219014ccc71299106143a95202b3d9370a67403945e674f7986af4911e98d20fe2243a08d35a12415d9a2fe7bd17c87d92976d26b4b17f45416c107aa998a087d5f5f5219b8574a4b5118b91ccc12f15dffdc6f482dbd7e5370d1b6a07bbaf92e65cd99eb67ec9eda0d2eef71b4b79453b8fa32f2b209e937ed86f742f7169acd22df78b7523445cd38c261e373ae3af10d3004c24732fb1df01462288119b660737934bb4bbf753548cfb36c7ec01f0a6efc5996d771d27b0b0e1cab00d75d14cd80147a0d2b2b2af02bfd6326b27af677194b2bc3bfa7ff97563617df91d1c0eec68f31106f3aa66f22598d48e730d81888cfc0c43f182e71599d551c32ba8b49780cf80fb286d653c8c6f4ec62aa7c44a2390a9c75302e638b83970f008527637d9d9b44d90f09f72f0ae1587c9d9c7be7ff29461a83fe3d1e8610064c3e2cbdd42e64e19fa349d745d468b9c5dd9fbc65e32754c40d73250362e09d2aec8974f0ca1daa56c3afb49c7ec88c8f9f94856ba4ed6146720c960970c53b51adb16e5bf44a6561cf2075db5f7b07af275a0810c8806371fdb7ccd4f19290f04f9fa311f952b5642ad118800cca55d133e21efbfdee93b3e8c26b1213ce77e97dc8a42a136b9477d365f4af529b51679c678a4e797a0a72e9720911db155de6c5318457ead8473a494149da5b7b5e59cfd66ee30f3d4c78e469da910fc059ed5327f4ce61a6b5b74a17a3e05edb074d522ba344a10578af884f35359ba394c8f0cf7461a340decef81625dac9baa42dff2a95dd9d011701a8eed8a5cff27e545ab3ada04c59b3fcdedf57046073f105e013aaf4137ce7b116c697988ecf46a0be2e81ca7719b5fe49f213a3f2e14ea4f5f0d21b4257140319a8646a69e72739bcf276a1434b991edb91c914ce0c4d1710f6c41e83f95ed0fcf5a8a31d1d4911ada5e1c1a197d8d090870840604475272ead5db7bf471f47bca884682a59309681c76ce2bb7dac7d42d53b251d30060dc0df70f3a58bbee29c307d3f70a166e7fdb06f375bc7dd6f420b77c1d191ac8014a89aeba8d108fda92fca181e811b9923e9917dc16740e1d1ae55aa39b0cdce241ef682f55fb493f212ab0c76fe52ee773dd53d5511bc2c9b976175a6e8fa6594a66ee7a97467d0f2130c0f163719a9b4aae6d5c6496de19b2182a95ee5b5e920dbb30ff2557a2fd98c6dd58eb61651fe490c0af6cac28003b69e61cca1a9cca45df195a5c346cf885bc6b261d28f9116c411e83f38e907d063a2204eda57bbfd297ab37ae7dde9b2d54de8a641e91c4a7881dc5d0281b0130b6f532eb5ddb833d71d1c1c9f9fd4b03ad27ccb88c6cbd1e222145cb3211d83b4c842e51efe2640e5e65ab7bd2bd621ff5b9b8652c231d162bb302451f80a78a9dd5ef5dce852237358723daa58315e3bfaf528ca972c4ed4b1ebbb17c6323cb61a7265973675c7dec8cf759cfb140680b9a25efd8410006fcf2cca34cb3677f4550022ed5d2c2b896da1e78e0d7b77ae91505ea3168752b6d43aa8943cc0e74e09993a72231aa481838c66bc52c7d09a8c8c9cb087d11a6d416679c561ce6a9ce284add3113d91c2a2c53e38b85e82b6acd06332d967741889688457a0fb8038a977a3ca9bd53798d55a8eef33e84490ccf37c1cc2a1e92957a5aab1e7f196d8b6df7d9e54a3cdc9700ce46593f8d7126c7796ca0f247242441c9cafe50d4cbe39fffedea4cc835d40974b8fd7346a5a22394adaf274e6d3efe503eebe8f496cbb683abb09d472455a368a958a9015b8b50a027e4e3c1d411799f515d7f59d553c2fdd661c6370decc1b372e459be51dd2af7dd607a10292c937dd01ad60390c63672b33305d88f709cc3d1f66b055f07ffb8c6ada60da5aa82f18bb2c4c36d441cf35597df9e73ef49e18da72c08183fb11e91718bda905ee91cf90cc8bfc87ce080e2a15935290bdd4540781caee4b3b0707cdf875a571db0c2217b58188604c6498ad2726b34574f0c7f71ebb1bb3275bdc50d2188b1de8f84bc763b92c0a5e59c601999d72eee90b462212e5f12195eab57c5799a7913a35c62c372903024d6c03a65ccc2b5893d2e9f38b1aa70930ad1f15f21e1563ac9e164a737509e5a73d9df4025b26f6f522d38e2706099a56f0c8eada27456573332a92d65c5977d8d064aea128c3935f60bef4282d6f16f6a3170fcccdb9d0b54d6b395eb37b25c6030fe83becb3b6c1e258a78af8b64b2d08b0aaed9c1fffade9620d22e9df37a7afb48e7642b41c1b82b0d572aef0487f613242c5f24a3ac9951fa08a4c33b9a9cba8e47231aab1cd6ebabe0adc3c81c798ae4954c0dd623fd44f67bab4fa018416e1e9c5aa6d550d4ccffbc3ad591598b2f77f87ea8eaf0bd2fec8b513844184a79925d6ce484bf26a5e894a94f1afb3667ec08cb74ddf237cd9d01222831efbee1c3eb5a40690180973df965aa6b2a980f55724ebf362ae3bcb6b9c6d39ba6d2adef43cc8acbd248bd6d9e7d4057b6cae154f45ae310590c3ecf5db39067b67769b32508a1c75f2bdead011349c25b287d2d1e159c1821c9f5303b1735ddb0b9932ab77b75f0aeb95ddcc747137bf6680cf746bded5fa340b9d06a307548d538ddde268fbffbb9c2e0b8640cc563b4ec32c09d5fbe88686f65eae01a1161bbb05db4a5b664a093249c5bbdd4018add8d1f6b03b862a7251246fb233ede0dcd36d2f744a872c5cd9b92d9e4fe205dd9b0d0d5e3d6062dd71933cb694df4973359a8c0a499b85629aed86bd5486d057275c0a433b85749cf4164a939e2a5a2ff11bfdc5198061fec71d7616ba7db1c98c1fbd17524a49ce8266e84aff3244afad66ec8141effab985ca330dea0c3f3753019bb82710f10fd9090f736166f091e90dac511c1fb1bbb12f12df3ccef9990782d1dfb4062fa2025def1238b15e6ee038c2531b8164d8d15b2f372b7567e817ee54887d709822ae9cb98fe256d1a5dfc5fd39194caa26e83dd3154a49c233e30d54459c9cfe864921f888ac14d373c6daae9fcfe7fec9ad2b753fa1252681956a829cef2bc82192110aaf3ea0dadedcf057bdfbe602fe1dafe5c4ce0ee4dea731b96178c3e9f4e4340d472da959076e25c962dee0ba942787f22e326d989c7d4b5cdc3705a26817bd15accec682ca100953347cc38eb248c986c579727ce5ea4132b915a6d9a571917ad7522341884ad3d3f8521b05862a6eed953ea42fdedb7511747a84589db75bf9a6d5c48353af96a40159e1ae00603179c2997c18204a2defb13e730a39cbc79d90ddd563045406549f7f8c46f577f552b182bb4e7d5c134254a7cd4067936edc50c22b2d2e84589b3210bd02fb5e9ec38297773767a517dd2b419e5c3b932ec6d0d31ed2454599851d3be8fb54985153d12a5ae38a3c35243884dac1a4e31d83b839cfeaede52fa604d09b91224219f57f9c0cfb5efb372b42e86d9f3741891021cea84d9d6b6b4acbf1b666fac23b8ed2ef04f8ad3186994d8a3d015804065c0b8dd73949e2e9c20505a41e084ff75e989f6366842fe182711b1075ead571632e92a7bc0c3df5ab324bc560944b75f41b8b06ed9a057e731e8b4553100ef6189d67205005800b3e4e0dcf0011ab7567622d6bdf5362ca84badd86580cde8fea78a0a3551b13f2950d0ef89eb38178962f5ef080cd4c6cc717c4db869c4cf58e15050365c825471966854f0a02905dfcd659cc7099d5c04837b075b62c4c2894d9e8d22fa158e23fa38a777f587c931ececd6e4a6babb256f64ee2f7ebf4a883b31ccc2bf3f54c5da70ae2bafb53df3e97d35dee1969591f15d1a1354de69eb1a98e52e92d7a47dcc3b87ca886d05dd93651e5cfe10dfbb7159c3993c1f24e1507ce443d6bee251cd7a5b933da57072aaeabfcf604bd936df49b749bc705e89d667dd9459193c060557b84ea13609156fd1618aa9d68c90be1c6582326e1e7b0287e53a58a96767093b7c9a1cf53eedb6f6490c768f275c1376e88baffef907e45cffc6f56d89a000e20bf539c4f11f75c4e2544cc84d1164b81b953d43555c4fdc50d557e4f4a72a5fe78ddd0ead855f92c9ddd22aea8bf0e53629f5630d0f3872394b5e267054322acb443f5f8e28fbc3f4ab884af68808cf8c8f71d6ea53b9e3d0220c990231dc51b85402bc8fd13c77566c0eab2020392fb9090296bd3acceab1aa866fa736a7918fc7aeca6da0fbb46a88ec3018d1570f93ac549d19440d1c04d88b9d9e2b9102498eafbcb8c387d1cf0f62bb304bcf6373592b9d28d9e7322b99504760f3bb73162c8fecf86080faff3e33eb038cef82a9a2f564afefdf88081eed39401c08631b416aac893ae584eab4b35a421e990ff0c1f13d912fa3dae025f74e6ace0cd050a5738acbdd3d911818806a2a049869dd423e889395ebf2e33b2e8b1a25be741ac0edde2f429cbe143cff01d37f86ab4e3ee581c988b994d881adef839412e1b374a88f89f60ff2c38dae7bb61f15797fed1a685148dd497ea55f83de8d8245432e3e38c1afe5943c8f3d8341444b9dee5f47fbe1e00f940d63d136a10c8d77e77fcf314fe4956446d0b7ac0b45194f2192abdea0bb2aac00d8a989dc66e58c56a70223813aa83f40cddf743f58fc7b41e28280ab3928f6d9d2680f17b6d8dd3bf8d853283e57f59556a840e98934d90f62cb41696efdc4375d6dc4f6818b9c38ed576361e41a0f68a70efdbb3850fd650f264f9ab35dd16737ad8e96316a87583615d7c325d9f8abbf2d330e64f4e2700900b397ae336a2b65edfae82c1107c228082a1e6db2d374d6d1eb3e1041a8fab48272b8322a68b4de268038631c8cd85b15dcc40e86dfea1add20029c1196cd74aaf7a435646d7b957480a6abc5395a15aef2aa84862e9d47aefa658bd52ed9fd7abf31f03cfb518515a89dab9f0972773287f252fe0bce6924f8096b1793f97181653e49a58e3abe6acf1926222b18622be05672c27289a063fc22843bb8aac550846b653f120fb24184524649859ff714fe29d1df00d6a2d271c806ffc394da72202a0764cef56b71a075bdc6654f915d25ba61efaa57fd0c0c1ccee1a66fd93fcafab4aba7ef19a2d7b8a2e6122cf389aab998e000ea85a9b8967d5da0e7e390552a985b6699813271aff1ec8189a3cd2e22806977bd26a5904de694fe3855f017d309c5977178cde8c7a10aaac986b7ad3a0765f82f695d3ddf1f953222cfc977e8b93980d1fcca8eea1111a2b07ddaa8b2e4547330fe0885ec09736a43a617197d5bf25f434dc53fcef1a6d8f692a2473d074518ae212be114d60a4d9a79418faa3c2c44a4fedb1f41c5cccef8c30df8ae1dc78addb8d17dd0ed440b5982ac55392a1b175528329453588e4c93b7090e863bba783479e6644ac6cd9a98a4309a2bf9ec4fcda25d47a10d9ca8c14a850c549ec9b544f54933b82408481afe3ebded6b5cb614fc9b4bf8864d6f7abaf32fe5d749aa3e7639bc34f306126f47343a12140b2cac458794cf318105c9494be0a3f84016935335b69d36956db0110072197676be20c2ccbe40276293a848ef44c8d5cf5aa2ef2c82a33d5fe2d07af276121abcf8d9402e9720cbbe239b59b08e9fce50fabdcf167f1f21edaec8a0dca5e6fe4212c2c22b03d3017ce1bbd94865e716b51ee6fd968a41f4951a0e5650c5a4c3e280edb2fc32fd40e135d216352f4beb87726b68a830fe2cfca645186962ef42cd843ffbcdbce3b9b3e478aef3b74cc47b2db0cb6135048acf05f870b1c1357770144b3b4b030e8ecd371504fb0d89abc21e2cbccd371a97bbece4bc1b7b1744eb29a0150de173a584a895c2b1fd660faa7740eb36be8e67b344afceab1c3d62cd87674549731c0eef8a2bf27ea798c0fcfd916790d8cca60c4386f619e7def582b0d4656f7eba2c2644cd2b6021b5bab84cde446d4ac801872cd64e0a25fedc9a9b538b50eefc1c5d9d5b71ee92246bb2890275a5b0f187c47d86f8ff0d986f1ffba190065100cb77def255e45093aa7e350796b52aac3e6d6efb79ab0e9f035f167d35d1b6a54198d65831c1c2e19992ae9d47f5871a1dab94a74b697c47ced6368fae0203e1742ec933b8289a75a5b0d739a1781f6e8b97a16f0cd891dd6f1ff395f57714cfef00500b5fc22e371024c54e614da79cba89b9031ff14e0de64dda5b57108178471703f3b7df0c5cd4932b1b588d24329820dd5b3b53528889d2bb24cecbbec2e82cc9547a68c709e0b6e0180395e76a5275063d2ba25d3e4137fcf238517615671e88817d3d0dfe876bedc087465220710a302b051c3d220f356d7758cd00bd1d09758e1b29ecf0c417a9a85328bcbcb77d13a14bc2673e6d7631e119110ff6cd92b8b474349d10560f3b8af6d899e0edea9d22ddad9ac7b5d7b4ce754a3fa616e05fa01711a928eaa4622342c5cc1bfb84ef059823670e585f35cd1a4e34005c09bc50c64130502799ab92e6aa59b86134c2abc948f696c7f7c14ebea6c5b9ec3dcf2b23e3fba396252e54f34a65352a717f821d402586405b59677ba85504724f95fad29b622d633813ddb248514529872793a4b51247a7548adad625b113774ea9cbd4cd6706221cd07921d6dfd50e4ea6a24e0c5d7dfe1b7116f5f9c80ebc5798eb958fcf2b3abae07c07f0983e272765bed7cc9a8920b218d812481a1e5a5c2375ff1c47532de1dfd4bb93519a9c963fb84b360c698394cf1fa9ed097c00178ce4a533c6d6972b17e586f65d40799eebec4590ee9384cce02d8753e606a043ab67b01bd3f834e328a6770cb6351b9c7f46b170f9553555d7520c515dce7c7dee40ec2101ff2c15ccc6a55979f864c29647fb5fbe7c73539143a2ae8b01e4c645a3dc9bdeb2922d8cc2edcba1f87ef3022accf391e2d3cf490fc2e6d6a20b079d093fc50aa810e69f544858298ada00c8707de24234524cc473fd8cb87773a2e4ee9f4bd1792b3d9f077ffa1d4d399df2366f3e778f2232e714f24f7a494b20ff27ea99bf7efc861ddb6f83533413cf74d6b75a0aa7b620d6a65c63bfdeb22339e514bcd254d83ca339bf91ae90345b1eb2cec9798b4f9ff9f46bc0b2dcac026fc192136eb5ba6ac3da23abd122d3a14cf3fffcf38ae794a01799fa8fe514371223a6ed4aa1085d5d705670b9fff9412e909b7d648f5a87d2324dc04a63d24a12a1c015b3f99951544b7d7d745f06562ffb4dbcc518740439cbc129b7a9aed3d1b9faacfc49ae709f4b8a1eb8292239e1d18b7ea4de72d4c86508bc3f553075853b11262d9059c3d1f707632baf76a5eaf22b11318123904c22ac0e0622a64c76e88799a6b67e6d58b26fba9fc99e3627556e51335bca48d07c51c003b1234ca094f39c55810f1a0b122591985a394b33745fa6b9b6a9402552b1f7008e1b3eb96ca6dfeff5629cee3bc12abb64e87f2f98b8e80ec5b1a027347f5957b81835b61437741d78396a8a7c9134844a306e046e7406bc8d524e32de3e06169458ca37856b4c61c8ad6961961ba0441b569d3208cb3ae56e5326cf4525653f015c8b7b502ade9909c061198ed3f504da7d1eb6a7c26fb184527d2d2dd406bf0732a2cacb591b6c022f65c731edb64756031ca935c5dbe88b2ff0435abbfa05686d55cd7f0e043486b7be0644545ab1ab6cf47d58f7a22e4deaff6faedd5e4c193c24fe5b0e1692640770b6974a35fd54f120e3d3707cee526d892ea638e14ae2636a9110ad3cb1aac62acef86e990c1e8fc453e179cd1c3c134993967bfe79ad8acaf0b5355186d2c22aee49778a345007c9f6a63e11024a707d534be504601097101fa86c6c509d9199b1b73bae9d1486c080766a433d591ba56c3d441f1418000fb81a4a8309020c8758d141693376cf77ef58a0af53e7569873a8d358d8da7df4b564aaa129691fc2cff448789e19b850495bfc757b45a192718b74ef98befffb2b9446f13a670c30ad11ea6992b7f048cf592b2abc31c2f70135530ed7e33b973a819d0d4f7cb1cd95922a43302fbd60d4cbf246897acd149974bc0351a78567aa984446b942c5e37fd984d0fcf3793a9d8a97f64d5fb8ba9a99909063d185aa09960f337cb8f6418546ce87088fe58c154955d4220e8bd04cfea4905ff1400c28317710af9a5fa26b3d6aaa00fa983207a60c8a141d3bec59ee34b9fffccdfa4a381b920385f5e35cf5f6e62dfb5305ef1a727c9184391cf0209e68204708c278650b71734e2429a31601c5f6a4c4ee8edeee5c04cd289a24621297d691c60bd03c1466f1fd64bf31c5eb2eb2bd704c792e810808715bcb21e5fb20601ef6ec7d7c3947a67b58e670f42f1488841668ff933261736a37c25a1e9193cd163af7c3f44b8b1742cb08558d6f2e8df95876420c22c3eefcdb10405c5dbabf9825146e1cfca9977527af04d99356885a911dc4f729bdefd756ba41850a79c504a20b6bb64aed02c49fb36753276e71c8a2b5f626bc2535b164740f6b4076ea92b2cb5ebbe70911fa96a45b2c85169fc706b2cc3d1fb851cf40c7f5314abe8532cb65614c2ef1e54454046955f06b63d6063cc7744eb4f2babb6e550e249e930fd9e1278ce0169aa9d79979b2282a45409e7135226976274d3b968aff5762ceb64b0ec6129315f8aef005fc8faf4ee38cf419cc3f2dd6f68f3a1fbc3727c6170bcee56192d439e815f29fd0536b8a3f8119a2ab848b21dd530b9607dd8dcec25cdabf27568e382c8832bba756ce5e22eb2e69bb24a4770cfcf76027fdcffb64a3274c214cb973c95ab75f2e06790ab1d12fc574d9d5f54705ac3d2877ef8fb495d1d1c8d9b0cc307cbda516cf1b0e801039b962c354900a83fb6c200df4e86e525d79b9a5a48fe78ac3dce5983f72da0889b05626ed9c684682d19430b408d7f9855edc0a33da0b2446f1305df339a1ec094b68b8e569e801ca09bfdc1e39e005f19b825b4dbd22c026cb8750172f9d86ed96c1445c8e55cb51a29bdcb7dfb6b13db561eac2a531d1943d883a37ad48901bb3b0264adae91b87439b45d44312da9d797dc5b0f059e85c7b5798bd0f0d154b9d7b449688daef998be345666ce2713e94b78b7228feaa2db3622d24fdb029343a2f0dd9d6de26b0ec96568e8c4e546f36eabf308e20bb397e5b9bf83163e04003233c75adaad41e866824811cae7802089dd3e63a6d32a8e9564d51376ac51f50c4cda758fffed6e75d6d126924cd6a9a0577fe77d770c1e558921bf7621d0886f26323451030c7b261f0ce49899dfdba68127ba74cf37816aa4908af525a109a411acc21e44a6304b3c1dfb1c7fa2f1941957808e2c72cf13f63f75b7330613d99333ae7733f7767fd6579c226da3367e8694fcad506a456e2247e44a3fcc261973143d080262574beee6461409a6fa67bc0f1918d6f96f488709074ae339b243871d6234f1a9e21ca0429a8103cc3807822ef92ee44ba4ab9cbed21f9a572d55d57bd6a078b8e12a5d34e37a64b1ce70575628836e8f1d195209f3f02713d4d90a416289c046a0a2b9861fd20682f41e3605aa0fc79a3b6ca6b9848bd174ae0cc3beb941c814359d643065627803922af8db6e1cff8fb3c98dc7fadc109b6e18b1cdeb6af3730212722d914f72ddebc57540303f66301c2ee2f671a59e60819f9718b02b3b5efb483096561e0310ece6b82c592cfb0a1ecd195d496b7ff4dac17969dabe0686dc6ebc465f46a09991e9937fc3ef6a8e66ab3886d5d40d9e2a9694a691041bc54ac8d23a25cf61783fed2a18ab9f40253f01f39316a86f8d0c061ef9714d727fa1a92afa433e2c4048cffbb44faa2e7ae59e959d5b54eb869675825397f375d4c04c67f4bd4657bf080bfcd6e002aedc9b63b95186fc486fd7bd68bd51ba5a227581f8c08f5b94426d326925161134bdb156632b1f32718a7f0086cf7429decebca3c43215ec7d18b4fc58c1122856b6bdd4e6ce8191173f2beacd2504ea6ff9e55396ecbdaff4dd783b60d418190303dd9b9616d5fc97be5999a846d3f350d95d6ab9cc16d8e768529ae757b3af593ff9ee84a447f7ec0a9a31df7f98548783f4e0929e615eb716f5e2fe0ece56132e5342081ca54e0a3bcee32ec8bbff5bd70a6f5f5fe223d79348590f9aacb7b21813b3fe9f7a6d1b6d41ea5d4f4a090b6d0f84c5897ae7083181c0160a9a25e1a9a667738220028828d283dd98e84ce1ad5dd0eaa5815230484e1073cc6b78d2dafc3a4885249cf33055545d23697f0ca8955dcf9f9b1bca6cb54bb00f436a96a7608b8253ff689b08f876af102e23b706531ff9c3afb8a3c8764c38afcdf79b31b01ab36728b2e7b73b3713d24e4a287ff8748adcaae67402e32879bb851d1fb530f50559b98621107cadd9c262cdb3a1febe6445438e64e300d780a778dbcf55af71f3f969b1eb6b879140242a7895f000c2b62683e79873bec3f86643daa855862075bd8ee7c592dd8c43d785144df61226c4612b840f70c01b781b35e72ef89cb5e883aa700c31070be1da732903500210eb65e5d1f66b3c184468c056fae91ebdd213fc9541db9c65f911cfa53683cb936414873b1041f8b2a66fb05616a9788b6280864a0c0c3dfaaca8d2f6cc96ba0936572ece57450be979a42d27cf504324a09f8f6a8cef7439868caebd60d8f38117eb29a9432f4ea0edc6e7f9c6f5e855714e63938fd61b322023492abad28fc1e4e2cdb35bd74eaa89d129f5a0447eaca1a1da97a99c1c6b4a7fae9783a3958062cab78f3903d309e480c1cad8686bb6ba88b0aacf569ffe6ff3a470457690d1b83d617497debaf4fd1366f3df82c7a015f6dde2ac8ab40290a76d0e28cd8a09d8a534cb00fb157fe0dfe00cb83ea3616d1b4a7c2caaa2de85ca5fd7704a1319f4400d6c7e5311c7f4af78a3c126e3692359e34415f84c275e7e379a2a9836cbcf91f237807acf41edcad36ae82fffce7e1b6d6d8e047842ad2a24470a6f5338423aa37e549116af72064e7592a59bf2d95212d808f7e1825f3e7d929cc8b1ad0ecd4d8d3f258206bbc04b7723f1a46355436bf4b7b637160b6b0ef0567e28d4f2b8a611b14a34eb4a2a80952614810d862447206ef391fa4c923a972222d833b4e7d3272ce256617a6cbe1d473942dea6ae1b9949ace594f61146391c02425e401f6302718b19dbbc044c10d02a265a76c8ddf86bf374a30e9fa0a4ae1e760d84043e38b628bcdd8fc0060fcf30ad08929241064a052d3e264d24cc23a36619f8af8a27f078db7deb55e6dc9987c45539d9269eee312e700f370148edba09017dd6b664c973a7df1cc5fadb5ca52d39a0c033ef3386120e2dda138ad8b55f8ad8b11edc4d14a827c581d7d40171d41253075443da3e5fd1af765d8ec14fdf80f6524da28f8192d1d4cfedccc3dac155987dc0edce185e7af8f182083a3a260b09f4b5583cf9cc576b5ab4c9349cb65736a60b3d18862bd2fc0d59985fc5e537d2662012a878e530bbe5a0579ec1a959fac7fb92d9b228d5bc93e9831d092468d315f7ca64b55dbfa57b8ad9985e954c3c16e3627d751af4bf5cad5ee07f040d62910934c07b692bab1f32fb718f1b04dbb107ed627f627f6ad7e73e760baee13a5a9d7466406e40a30c76ebca0d50c9b435c48fa8b0e413bd8922b927d5c04991f0bfb47101321bed629c1ad1ac178b543824b6db52199c900ff2625f52fa2f254e8fb7253ae308f06864c0efb77dda4f996832352114b1c994f19b7040ad4209149d91789c7524d9a73c0955c4b6bf51ba1aa7ada166842bbc3b340198b2fe85c05e353187b1a0b1084d33e96949810772f0a1619c8bb9900ad6827c91babb143bf5b0d86de42e89e8b81c1dc70b39db24fe86203fb5c7a58c2dc9f9cd78463d4b3a50496b9fc7f8072f0de6cdda2f0aff859864c10da5cd0ef9b4c826487e81259e5335c58460053a8b85dd32c98f6fc1601aa55eff745a07eb28c7f11c0905a6d32533c665a666110b8da7ea73a5d88c8902dbcd6d8d26d1f70a79312418f4b5f2bf8fc1626400ff9b2907b786acb56cd98c1cdcec0f3cca18f3652f7cdc3dd9b9d9edd378d3e26d13960e2682347dfd33bfdeb35c4aff7a45d62887c73d4f68602d9c8f9a257d9dbdc9d1639bf648d7ee43af5f44bed97891383ece673c268003ef0648a1cecac55ee922fafc6b68ef67a1593ce2de9fcba8d0a949a74a9f9f7af44c03e916042e332200a4e118b06c5e548448e414121663a2595e3ee59bdede44780e1709546dcdbe997ca958db76b1279aea76111a5383ddc9b07cfa7d32dc9e30bc959de0c2103d1393b0d60ca7b0b513c5194ee8cfbc118848a184eeeb617d8235ae603a49cdaf898336553","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"270575f074dbe34ca969bc1be1e8f61d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
