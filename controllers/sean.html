<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01fbf130136ac1165106f238f6092b418a91d95ecc8fb08f87b019ce22cc7043192c5aec598d1da72fcfa748fedefa4f895b073738b0ff8d4381c14d07da8431b7d0e97092997784a16b9f66beefbf06c6d199fe106dcbb5ff5fd05fc44ce11dc476e92a809af903deb870be6eb01ba8c889b48392d8ddcb1aa9b247565562ee03b2771e1acef273f254985b2b1b43e8f7256e1a3c48762c03f6d7624eaaf336fc511beb2b53b25fb947ad5268f0489425b5e9b9803a3a95cdc3fbadb24cbd086c78b0a79d3f3c33be28f9f1856d01a4c2081e93148b1821e071590ff2d7b85e88eeb5490a4c330f16d107b09bc83c65485dc6a5fe6b454af70f2e4b8b169f77fe1da7964aa837aacd8183aa05b21815da2fb8ca2c93673966ec0a03d8faebd33f870c6c9fd02705ed2959a90336110bc01fd9f08991ce27aa84ce9f8d5465f3214d8c01b0b2e1a0d2312862bef8a8e033df1d4006ae59d6f7dba550fe55f3d2b710e15d0c31bc84acd75d6b1361b66fe59d0313202613c809ed11fdc23c795a9f352f96a4fd2474f504f642e13ed28603c6aadf331f949c0bf46441bf89b5f9e6803a51f39b883a51ba884ccca68590ed2b89979f0e72799810af227b596f295f3dbbead903ff7cdffa0f891f6953283b84790cdddbb5c3045e6b14fd1daa3ee9a9edc9ac1bd9ff567549148176610ae52a21586d2d85c4b680a1d19b9dde1a5ba8161b21b505ac86c609eeb8e5deb9fdf34f386301144597b123dd0651e63619f99d35ff57d033f3de9e8231c8cacab6901aa9a4226133cb7baaf35457448d936183d01f59b9e1c28445084494918e5e7dbacd77c294af1b8ab156593d39959456f34b68b268b5f399688110efb05ff94af25f665b441940535f922fade94f1e8c0a6618bcc9655f921f05a81d364579a1a1ca49071e3242b14216622f6d7e395ff020ecb727cda12a4cafbf64506e9a6c763be616bcb5e6f667cf2c45d13c05139129daefe2aefe65fd004aef4b2ecc2269925a16f0572c48caeb4e15d3682e623446fb1b4ecd0c81ddd19ddcb31dbd8dd0fb6ac0ba608c6ccd6413c4b8766ccd2d82dbe2d49b9e32bf84c8acd7fb866e21dd1a938f40f0ff1d857eea86b2d3802ea72f09e6d122661a740eb1f85339d460c5ac8778b6459c40cfd0c69585e98c2f8b2808f3b5bf20da77fcefa49d8c57786edf2096464b528898bc2defc99b45401183f5e639f9659b01298ae5477a8c3c2e7e0e038d06541001c33b39c503490ff710d169da74c74c2150997330c1561204c9ef837e29b1cb8ae7287c5bf36d07a24c2ddc571d26bf0604a764b0c31363cf96fb0f2870365e6c40dd4e22fc88dabcbef974e60cb7101c3802d1a6bb0539b023374904b383cd2ebd47a06f22b2910bc6ace09956dddee9c75a4c74456a9383f3a0449c61e77cdf2af91a440b5c4280d3da90908ec99602bac38affe716ece27cef8ce50046fb8d8b7432243baba96b9a13914878cbc29003299d629f8cec36ed44fd72e92f847cd7f9733483eb4414a095d63158b2cf3a191546b33d6370359328a6796292754977c05060ba4ded93ccc67e24ca5de8870a4c08c08654d12f78923b80fa573d55fba65d0e04d3e12e2bc452ec5e6c1de5957c52a902bd7db96e66b8c81852d39217f46cc6a48471eee6affe432cc0aa41387c1841bf878b323ba0d89f7885d2910e251cdf6481a32f0150e55180bb10d0e0a9f1afb741618376f558e602195257185b7b40be489477bdc4891e8c9593cef0a59a507a84b68a2c0725a821a1045d8aed22efabff1608eac80d5f806bd25973eccb74aa90fba55348175346ff1569d7884e081713cd2b9d4052500a4921733410c78132c6f2cfddac0b86c8d47df9dae3cb42b0bf1eced50f4ced1b3c7e3ef51e28046fc76680a7a4b0460b895278a65240bdeb1be0eecde4b9d46abd7a22c5124e8c1e81a231571fee8b017ba6013a579cd1f40c788d39bb2750d63ad8ccd0b88a5780ca48712c53b921c7bacc4d303df46322105b0f0c29329b794643ac10e1bde471d09a8607a7bf24532045d7cea2af6c88658ee6a397211cc0ea171d6163b260a49a99e1dec4440a0b377c22b0bb1e3aeadca5a9dd71a35951109116aabf4bdfbc5afb6dd001fd6dc8555c5a3bf8bce217133c4bae759f056a10c943294890a22a7e78b59e120e21cd9be8515d2d9f9c5d04c2359cac2d25a7f6fd8be3354e3e7b4ac32602bf25d3e9c9d42e0e65a39510b6101fff2cbefa7761189771f01265f0776867ad117b5d3f8f027ba322fb2f7d4ca6f86c2569308d9c970a78a22496119c5fd53514777ef74f09fc33fd9b50b8ef2633c3ec09657509a2a5787f7701babd9fe3fd1c3c8ad44c8bec97d6618adadb6bff6292a9d01750798551c447e0547fcf335d291f0064a9e91f2e7badf6a09c2dce1d16171b27f116f49f4112ae167fb21917f749b8631efff5be7b0a171232070c562b03ad299ed1a21b535a6da127236fb2f0153edc8223be7fcc5f26e382bad6d9dfaf0e642192950c5519a9753fb9b1b6ad4133a4c945f7cb942189988199ad1ddfde41f9acf5f4f2097a05301ac4ced6dfcf8763cadf44199da912298fe1880e7fad340666aabef0c69dc7520102a73dfe4fb493d1b07076749eeac0e3c69e0942305b5dfbb5cdf77e005e4c985e46cc29b26b7fb4958eb442bab3c8eefcc45c1735dde3e92ea5f01da7448ef809dac08ed3bd02f09c05dbb6a0ab60c1083053a1a5e74bd608effc185d20cb62a5aecc907f8821e0948b1ffb3e47fb093dcd94abec48dea98892868e4702f9654d963035d0d88e88273954009c05f24351fe31e6cf6f2eae49626032b161def4bda2fdabf8b933644e5177cfcf5452f3d8074aace2a60bc48772c1fca9a662ded3efc592607213a14bad8c176fbf264f9cfd838a7ce61bf0a683cda2bf40168a4e8a8305650a6ebb50c05e9636d656c000ea37dc9cf4b845a195003bd214602eb264e1b71aa4dc5551b9c91c097513a653d0cd84a26a88bd3729711bb71965bbf289e14d4aca8cfba52a0cc162c5ceec0927968de8cc3ff6068345ef545fc21fb3b7aebf2b84933c8f00eb4a9d778b0cecbe34d6649fc59aedaa379d3b5f2bc4d50d75e454923007edc495718e2aaeb7b85feea9f7c335cbb01299d4d53e37415026d63ce3903c50032af245daf3c232d7e3a3a75c6e9ac5cb6ad8a35af03f8babf831f29c40c5e2c6fd0f662467647d15d6b48e1ef119c43dadb6ca43f226d3ef81edc8a5bc897e35f3121a69f9f31cb73127bcdc5a0c523aff0617231fb00efc3e1cee3f25deae2e169233d3706120beadfe24a871ac9240ae1c525d157da8c435f747b1ce47609e90f9cb61d8985d40976dc7a5ad159af28e0e5c3ac658b85e110209d5bee1d57aafd24cfe8cd703a9e3b280d93b349b84cd54ab670366eb6825c42e9bc5dfc83b786a3c0e08025bf3ae70cb51210527b8b89e7b687752110772aa006f7f5c401ae04c49a1e16ab2c9225ac95fb5b197e97396afbf989efd9dc77a0f700436d46b4dd1da7314b0ba63e2345ee03e0fc20dba17c52eff34b7f0dc19bf97a0a953dd6f905d37c4bc19663db00bc24cbd94eef90c6a7cfe29c2973c68fedce87608eb6c089f571f07b8781a3d39a8a079e5a087d451f54e68b779d7274802f20ccfad16908076a62306cff32d0217cf15374c902067bc5964fd6f8e56b183ded422dac23886d72917d5d48ff5d034e642d2a4345c975b97ab7097a0e410c9605cadad328476b7acb95364d1438557effdce2cccf710f75993b1efbf06c6557d7b54118b27aaae6c9a9ad0a658575fca8feee169a395f7a4d89303cab4f13543d03662aa0379972f73610bd51b6123d5a8522308f35d55c987c783ff9cd63fd1a1a4e6f5d9330f39842f5b3d9f0e65f0da6ad75f9945abee92a760be428f748eda3b1878114adcf7398cebbcf5ed9fdb52c914084dadf1d8c31b2ccfab5fd7c43e85aa1f430ee747c8641f668cf0cb00b3201661174d3c0bceb90f63036237bfa36034f5259716fdc39ed9dcd5502812912b6b72b04ea90b2b3ec92a0a9e551914cb3f1f8e966a4aed8740c99574d2f7614b782a6f32f69f572fd92c5d616030f049b2a99987a3f708264dad57abff7cb8e5054578961c1a370a8941662924e52ae646660bb92dce3ebc6a21a8797914b260c39cc54a7148b85c035b6724989e38ffa52d7029b2e6bf9fe302465b775d4206ec46f2134fdd295e947b7fc570dbeea2b8a18613e5efb684ab4d945cbb30c35fe56215f5336d063c8fe7a8f8e842d9b5c2ac9131faaa55b4d92103fd93e5796291cf123df94838a9955c9f83b7251cf08d46ed4f295588420e456adb0b2edc1f3c544604a30849171994e8a92876ac8880f60d999f5ad3235999a1320c629e8ecb6bd2f8acd52a9a0d7efe107e8b70997e8ce065290db4567a5f624e4305218e58cba2e0c72a46e2af810d6765028a79c5dc1c41ce6907866460ad462527a4e8e0371b8a9a289a8763130d08deb790bd7b675aca72f4557808275b7d4c4420240af051f7ebc38d68f70b6a30a25544bca4312387c1f100a4fb887b694d1fef955cbfbb4b23d4b911acf7fc8f04e27e92ef67ad30d79406fa566dcaf0e24557acab75a4edf38c1f9928733d3d3611ccdb4a38e20a590082cd9482e9fc12b82c675d59514c78b1b9c761d8dd721a2a5e8f6fdf2193764da19096c37e0cbda86bace6a0434158b21afb373c84665bfe895955d20b525f56db9f6f1a065d7d9bf74e90e57410a827f8bf930e31e2f31c61d33d67a4db449640246f2efd2b88618113d9e92553d53384f8172039c5785bfd596d0eaed43146173e46ed91ea3dc9fc58f12af25b4a466336fadefd719670483152d29c29618c529205e09cdfbaf80af10b7f0dabd61dcf2ca080fa7ae9135db0adf7a14b9d024bbb00ce762b9e1506df68e7531e3bc6394f3ff1d8cddbc5ba6585eeec0c8ca8ce263fb115bc8d5d607a2e7ca529fd79513d8ba914b55f3282ba8ca1e1d0c179d8da49d1a793005107cbc471f070657a6fa0aeecb50e8b005c0332ec2ebfa51f3abae7eda27cc7cec277180f1828e4ca7e4cd0c4be81f68dd3925c05c99a09d4692bec61973baf43ddfa7e165d03b4773349a7097700b1fabc69cd291f1418a7e282e5f549f4d2c407880bb1e26966fae01162ac0acf8b13053291f416bbfdaf9e9602d13df07883815cab4e16410e234f6b82179e0507a0802681b63addd687a6ed94496baa793064048b7f10f23fb6a9fb28125fb4a3f295cc5b284568d7418c68ca95418d4d4d3def1b65fc6826861d5af4198a6b55aa48d0465dee5ddc4936d7b857a7243f5fb01e39e0a4dda85c755c3948b5bf1d9362d5463a92bcfe8cb8b4ff5f5facd7d7bedd6deb4f747e3a57f7b4cfb6312bfed575c715df7e306c69ca27551787f82c278e33a014cf590a3fae01347bbb2edf561cd77cb5a9e0a5f2e75f6804bfa271216ebffc5015253d55c9bf950f5b6a766f5476f5a1680c8f243dba4748a65085aa0a6c48b6b5e68e2a04604b66c0593aaf7885933dd0d65bf434967f2f10ee39116a44657d91641488b5e260bb01d1d40b72bead392ad1c9feffebf84ba7e41dfd39d96134fe1a59ba3fa5e78d7b924c1244f9290999368b0923ad83550fa6b9efbe12854c8849ebb426d5a581676dda6c6f249466fa6a6da45862ec98ef33daadfea7e265faf6847c6da2bbe7242bbeb4179a5901cab6357ff1b662a32be5e54bd12942816c2be85c0535f6f22b6c5d22392905d19433dea722d0ad48e9f5c7789e62afb189e46de680b6d49b34004508ef29c418478f2c4a148c4966e1d0c7e1fd51492752d8a2ac31781412bce1778b2cd5aac15ef000e4df4e3cc853eac931d892b1c9091ce61ea33e07a20c5697f1d5f0f0b66cdebbe2ad33a41887c8222b0ff97ce7a31b8e13030ef1d9cb52939ca2fa97121968426e3337f6e7d2eb3ede36ae83c49914a444bd2e6a2a93e0f4f46fc0edc6d370b6c32a0b92da885945c1ba2b5debbed2a18283f5b9e4d4872898425aca93ba6c5448d904efcd18513637a06b774aebbe340d19fb12c40eb7ec92ff377874d4e35613085314df60853adbc0e397d40258893e530c89a587f8e4c1cb5896bc2cb1c9f2b5e2b86486fb6d14397ba321931e984bc8d758cf3d177769f88355a996381bad488b07623feef2b5222c6fb16c8754bd826fee018e7af2f4ee8ed66f255c3f2a168da9723f6de1e7a6fbfd0b34f74604261f025ae45287bb0c4b00bd57482a093cb7ef29fefddf2bdeb4544822a60d389c0510f5e69e5785bc360c07de0ea16e558ab1c6d3f5db18a324a1e5c28082079863bc0593d57c0c017957a7f10787cdc93c86564878d33e1766d4b212e0a40ee6159934e3c7383e88acabeb9dbbb215464a81e0ceef959242a45ab087e686011df0294476408eb49c70d674e97dc80f246fffeed2235f78940ea0d38bdf9a3532cf112c229cb35cab71c85c41b03781b54390785f0d0e27f41fc5480843e2829a699247f46364cc7bd6586d26f2023185357e298eee0fce5f834a351104bf9a67ba80451aec31da6cfc5aeea518e14046f1ed54c7affeeaaa8a5f7ebbf9a9c64b68b4f86e82a90f722c2bf15129f5942863e9a7ca110400b688b2e89bee195c642e4dbaa98be81825d8e3e941dc6871b78998fc686036879cde5cde1772eaeca7c2310a4e425a326ac1037837cc0556e1b69d324baffca3dec7fb0bbf05b41cdd8f63ec1321f44031b72f13fa44e27952a41a4a5d2f4ecdd9e0ba9467cb728db4ae378614f5787c852ce5ea600a0ff5af25bd0f9d82fac7aa6dc1d282d80b9baaf33671f421b68aef1f693df6521840f7b6c7ad18ac01398dfe99cbd3514fbf5f43d684942d7c7c3cdbea680eccad4b1feccc163687432ae07616d1c2abb038618d1d474e4fb3223a291f7e4cb8e137f54760317f7b42360d79213f655fdb3fcd70a6a63f64cfcf53ce14e8247e89ff6fe0566de7fff8be5b1a1554d99814a13510741e6fa80807eeacfd67160b44604037c6bc1eb77f52b5aee48fc56c731f332cf5961c36b0b98bdadb356c5fe18ff71fd8976e059afc5c1957fd496d1f6e82368469a86761ee84ddc748f0a0ee13f662180b228aceb866b2810f4d91b59bd916a2313c5cefebca1d1d94784f79d952fa5ffb13874b0d58ddf9de3d6c9dc3d973190cae5cf1e1f23c92787795c9f54fd585ed4e57ee12befadb327fbb21de2b24f86792549baf7d9917786e0b56c2c004996034cda140efe54ccab3f95f1f88dc4d3afe13210b1c725259c93afab9b0de8dbaefe4f416f0c8dc0c198be32031b1460c150bf6010a2757ffd5e1cf432585fd93f4ddc40e50623289fcd182b8d3905025271b1e56d3ef20d133db398c4105e2014c01527876d2eaf35bbca03932e287d23ad9f0d0f66b296fa966a7bea9a996c1726dba6e7abbd9956368a060e7cdbd2451d0d74babcdd5c45d39bf3df9fe94b31863f746f600eef4cca147a457de31e85d3012d930da60890d0608ddb734164c95704307c15777976a98a4538449afda302f3d706362c764a5f4fa8c390b47a6a0e74b56f07746c33c1c22043921d0c1d655a336ba42a08f371b050216d46fcd875a68d008294580b24be0ec9a6d560d6aa7a658195dbdd1f6c415eba01c79faebb0290d8d05b319089860f9670fca2e7837fe7add3967c121af50f21c9de03e6539513c387cf013585af72fc4a0792cb32b3e19301b005aed6b3be04f043dec86cc955562c56c8b3e50be9c7097305b39b4a2cee096c002e6332e5449774bd9f16b37f84df7a25479d0d12a4240f3d4b25d3fa054262c2f7f3243a58106430b8fb2498eb9f39c1da54602a84eddb4796d5284a0ca13ee28e13ffe4da36ff05b0d8fc05e863add77fc1d8e1efcfaa747753eeb3823ffe429858a191eff3ab840bf8cb9837f60e5591b82503e7c6333aba104ce1895d7d40634a25fafa8b9d65d52fc4b06b2d1c42a519cc1f0bd8950f0588f3d45abb18bf873b4e95dfe82f0218adeccf4c212f62b6ee98a4a596ad5b66456b070f47e8099c6016e8a32afa75bd9d00e3d64d33185836370cbe5822197776bf1dd5f571a8eb245486aec8ae0f2465f9f3b83a101b9a79b814c9974998398dede1bfb2590df06933e1035f44d5924d1a88d74ec36d63d072348b57935df63b943ec59255222aa7795c08044aa24a58751c6ef8b4e7250cfbcd737172355bb36599611be1825b36e53a5c035eda1142ebde6e4fa90fa6c04dd1effd5e50038debf43ba28ff4e9c2e902a5281258c221e2cd70351b7c86014b672e40943d4b37933c745661a16fc4a568b64831fc38d659c87e78a2f9e6628ae186b2b652f315f3973b6fb5c9e0562f92990bf2b6aea42eb0d57ba35c88dbabc994ef013a951154d1f529535974791135c557d24fc431c2cfd57270e504102e21f90c2191f08348694cf853487d2d6610d387ac59e77372583307f8c114d474fefe233f032414c2f53f89673625357211a3dc07382b385ed4e664d90895e6d4de5ba7a1e545b20a2c575e1131efc7da240480e872752176ed76833f583228b80236499077f77d0697b4ff6dcbbe7c2150c507eb18620bfdcad2dcdb294d2d3c3a7461bb972d862855066a0c3c0fdd45cc5b829628373d7cba3ba81746032a9669b9b2846b053a1f67ad020e086cedd5e7d67b956f2ed987647919bf7d697b40b2e6e8f607d44ba171a9adb06ed2f0bf2bb30b71d000bc2a6b98842d96ccc723452f9d568bd8d612deb6350f94b824efa51f6357e5b7750a54fd256c732fd457d70ecdf5fd054604c736ed199f36d4e2626a3545a368472df3362b561277a298049dc5a59ea31d0ffcd497942af03a4428ee2e66be152db719066284ee9a00fbe6475f01e0d420536a282d3bbf9dd60a1cc9dd1ddaff01b568935db1f2ec794849a400db14e8285e76a19cc6b4e3930c4e7f58f7ef94967bc9380f7d23110d8c45c8862cde2e1903a7f97650af413d643039b576c937fa3a7b98f8c8e29e20fa920639b25694dd6494a5a3028efd7d77397486acfd34dbe7029daba0019f53f37e304845ed5f0dea361ea2dfbaef38f148bbf156db0bfa9cd59260154a4c313534722a62ae15058254303f5f3f8f161092e8d1759a003868b573218ba9ff3997004d6fb7a796b94dec4f9c15ebdc232db014928c219fe221a7e34192f880380f70da93b389f1b44e7a24fefb2c62b937296d80c397b2b0a1cff1bf081472808a70b25a1fba8bc806fb0da69b063528c84ea33ffa6742529c7065ded8c8492119e16614f6078d4e09bc77714431344d84c445fa705b99aee76f67aff20148a99f7660a76c7d64a299e3489b676d26ba61d97f88a3879050ea37ff79a637516cdb28c59d4782cd8ffa042a5fe0de5335c3f6f38d851b39ae7b003459deba8e7a3bc99d9361e4372e2046d4c41eedfee93bd7ada0fc5078df9cd990f3470f617fff9a8bae855407f7c98e5e8301dc97d259ebb8ef9b936216bce8d968cb1d2314f6328a5b4a222e99071a3d4a49be27b7037e284ffb563279ea2d4bd92b1d3e5fd1c21f7c46f7da3811df34464e839bd2aeca9a997288a13dbb7962616e414e07b508a3bedeb881b7daee9a8a22f9954fc1ddf4e801823ce3af8fb1b2ba6b9a257021076d58def513bfbc073c3dade9fa92149e31cd9e4d016fa1612ad57f4e5fe1bdbbea18ab2b1a18eaa6d10e7c5034dcb6c63577cbdaf39812161edf57350fe78773271b19c6fad89c21ae69f0ea89ddeb459a835871f1d60c5a43812151a55c123f5b21cae7f6561cb6213b4738dd7b921787b0eff2f838fa80b3a451e450282dca4aa654e71051fb6b30477809a4977edb55a787c84f410814eaaa77a49c82b7c26200e4f5ab08f151ac4b9aa6b2fe075f5821b0a84acdd6af8e329fd5bedfaedd8d59e4fce78889b7543aa6c690cc13aa4295b62dbe308c88828ffe3cb065b2af73776edd79db07c3c5f1d93d49ba3d31da2cc9f236b69c4fffd6384d02a5d1735fd052b7a8157d066cd7e4c639d776c11dde4890b58e09a23d794eef2255d779862424fe22d22983ef49a29784ded9650f5c9d0f3b6094e1ca3c6f9547471b884684a12efd6f945e23dde7075ec4e50ca98a3786fb9261a8fedf13fef69576d7ae02f5c24d1ae74740c034a2ea050f05aeb3a0cd5f37fa82d3dcdd76d687bffb9d746a294acbcdbfa8bc5aad7776910fbacf0489427e0249954e2b637005a9c842dd75eaf272b478299f050487f026aa25c9907c64c2c40e64e1fd4c175fbc6561fcc85862505c757d73fb5dd81e8ee76d2107ab813ce8b92e8b8a6de4a9e8546b9fafdee674bc71e5074c15fd9a4477a73720e44635933b2c5bd3a5f82af020e2ddbeb5aa1e02137ae9b4d190f855a1768101b22c1d6d30fa2cb316c00202d5b6af86d5123f8fa06d1537e1f9c63c0ba54e39d86b65d34ea6a09745534cda287fb9ddffa1913486e881a2d3b53d94aa7f9ec4c421335a44d52018554a443c476d2f301fc9051e06facfb5cf08b81f4b9e6dc0287ab7f878fe1d1571d9057f295945d5466e0325e28f9eac7cbd0666ecd8f38b091064b2318cf6fbbef6eae47a6b1f928991934d6bb995827022680718c849c60e8fec373093b7b8df2137f19a5e33ad3ebb81fdf46c6c1ef78aa1d6337c641987052e50fa18f33c6a943003738fc80de36f3d595538134f7485412ed9b54322c1b73b4d613be3f75250804af589afe25b9ccd8de21c2ceefe700023bc4e218f00dfe2b2317e3d3ec57804925140df5e0d99f41842c0fb0172fe38d57ef694920715394e4c5c92a942fe35f73632d483efbb68b2603b2fc0cd257147d21480b6e5b37a4d5e62822c79f6ad731e83753431eb28d7e230c4724355da6f4bcc1c4076c9e7d638dab8f6f6ea78beb8b30833318cf8635824f290c1cf978e4a89a4ab638616a8b7ab9f33bbe3cefa9313e007ece7362a2f4e081d11b9720bf862a17a6f5f4d2d6cc8f9411949040f96ea0ff02a79b6cb7ba054cb3113168dff2ee69bf92ca8ef94f62d8025168b748fb6519a7a5105027b74ff4d8bdecb26ddb69ad8fba999d7500b9057ddeb290186668549a982b191db63b7c1a580e2c1bdcacc05e8cec406aa8f996fa44ebdc9d3bf473603e656c8d431d33ad1f73f7747c052c93a6dd8dcbf823c5bcae213323475789d66559399b8e5f8cf152bf75ae599957f42905d8020802537a4ad59f0dad5c348c1064eeb069a5a490779d5be1f9634fb8cfd4ef5b285b3495c56ecabbcbf63bbb7112a8e376cd98642b78f6222d2966067509d041fe1cc5e62c49497396cca8622ff8720c3ad0adf27f5bafdbd8216a20c0d6dbbe0a81791774a4ad4fe13173ad8ba2593010481ddddd979219091bc050a819c358cf2827a5a8366164a54419af0ca7aaf53702e048d64af8904d26f14088ce0152a4266beca897cfe034f523da63ccc6b54fefaced7a1cdf35da2409a06b2153e1b5d37f16ad2610a2def4d2f76cc01edf87ff9dcfbe8372b49dd0e25ffab55f78f6b6b54714521d53b44587862208398b90b55389727f3da1db3e69ef90c1935100e621daca7ba01ae04047d68090a8a15cd4901d43af7cb2ef38cb77b7f3278ab8b9a5bf8f1a7b8a6ac2f617d61e12f409965b4ac4beda52f5f7958d4141a38d6d39be43d5445b16e695ee7076312edae0d7fb87a51874660224baff70953546d15221b01adea48d896795a78ff456fb43162328ec11f981a72c9e141508ca854b71f033fc0b49ac22d30ac6a0a926886c2f8acee472153c19258ce5e64d15d952f521d9a6d92e5fd27d88f9703f0c964ed9ff0cc2c0757a3646df49223e10b3a900850ff4cc34b9537d2701679e2ef227c310e91cac6313b88a5c9131438cef14381448a28081ed3272abd0a9d952c72980f437083f3fb134105526811dc0d1ac0fb6313073f783858eeeb0410c746ef883c057720c32e6e3ae4bc408bf0c9a6275bbed6b738446bb9cf7d5ec58819f28d8541c6212994886b8a177c6fd9059d78f5e81a38f81e46c42e5f23ffef886ef61f51beadf613734bbe9218b1b59749b443814a57485e57717e43f2d0b81204b8ae2aec248b71139a86a40c83e7f4ab41a53a8c1a3cf5466ff3fad8deba7b8e3e2afc19966ca3cb4fe6e0c6cb7b1ae973f2ddbc4f449d0f248c17fce8e3354b19d71fcd956733c1e7b3ce85d29e8d9d4c4ae9a204a92fa99ad1889723c39a5fdc057650a82e54f3788eee96895c5c0c0a017103e9d2e22b1098f96805c0885fafaed7e7ce093fa9d66307224657403c16de7bf9885a778891f9f92c3e199455f4095858f6b68cb0da72bbcab918c2ce116e5935593c22832d32db56154a7c8c86d52f269dc7917bfa741c808e750fd405dc07a2406b707520f11623200c6ea8a2fbd4af87327e7096c45bc105c4a61c7c6d74d38155b6be5d74b2381b7af41a3389754f04e6e1d73d372f4e7f4684197af9b3b631c821362ce314251990ecdb3dc98c42247cb11969dcdf423157c992798fe6a7d6348930b073f096d5b4ba5200e866c31d47129a66f37a6bd249d9dd90a41cdf0153eca30804bc838952e9dc89b99c056e1758150f20dbd9c022ce3407252f160718393d7e89b602d470257c38f28b332ce2b090a67ffe0ee3ca6fe7afe61896abd30bd15830527465c7ade9066d7a0598756a8625df889d61dc74a238d26df76b21b21990900af80b9152f9da33bd1379e8ec7f62cbef525d89856cadaf355cc4803d9d4cc0c212261f83dca0467cd7de6205b98ca31afa271f9043ff6d346c8d10e0c8821d028aaa63445eec102a882258e19b4eeec9d917e8849f2409ac7554488fdcef0808a365862072018b86c730cfb1b2db609b9fb5f05b33915b3c306af6bbeeee1e1dd43da179df436c4a49a231b20b9d6d5f6179841f024af897985122e41b1922603e797717a74cfdbabc6d201ffb60a314d596f711f8895b0270416f2a1c2ddc46842e394c2754f70e65481a4235c2176a1c07e76839b599d2e4b2766a66323a3b69c7c33712c45021a099bdc0cf89633005625632d78c52eec1bb2e26549fad81fcba1ac7d4fe3e68c5186b00671c2ff6ecc5be53249648014dd10e9062505ee585ed1c54fdfc643581844216b144c641925fcc4f68ce42d1279075e026b259d9ad2283a66db13a2f7f98887d39f12d2932d07a7f9da98004cd99043c392a40ba16cb6cd11bc0a392cee61c2a3d7c61aaa7fab14a136041166c5ba3273a9e7863afce2b101757fc421d13a866ac47ead5957128a9b70ca7b68ecc2a92d160058f30e7376d0e52b6f2ee6e7e00d1be5d9aad74509c2097a16d92170125b5628702903d57b9ad3e3dde02499f2b983978fd58cc89852a88efbafc2b29ac9c7ef40cc9bd160298f0f13efd284b409933d05669a0929a28c386558caa3571191ee500cd6f39440632e9d313864780362dc10a596e9617cb99d3010f200d7f6f30a8bd1c262f05c7702a3b9fd7f7f0611fa777ad1666bb9456df7ec59c377a9c2e49e8b69aa2230338a084ae9de7ff8ea9f58892397cdb26a3b33b25065b06549c36061f2428b8f199523afc2ab3dd27556d37d54991a1786c7053e79896adc87d3c47972642ef84e685bfa60c2a8ef5d6570ec5de7db9e21e8c63e28ac9d05037e2cf90bb68f9f28bf9aa4e3f05c5f0ad2b02ad25a051ff380000a02bcaf841b8c3dc585be0337e024b2c485408be23f73519ff854f188659f933782b8acfae0100e313671f038daa3396446d23e7ec9c7a0d621f1ca816f00014a5e7d3ceeffa9baf7947cfecbd3cbfd622269d1061762a6c368384ef906468130f17b1315211c3d474363b681a60df8dfa6cd584e9e6789dc9ce1db32d6d9142505b46450cb1d15fa3de73965ebb3a36c487e18b184c0abe3509bcb706ae1d197180cbcf395c639fc2413f53a94d8ffd0bc1e56f7091f8945c6837d40e6dff76c84ea317fb56f3bf3684e4f608a0a53947949b77d67a7e8934a92ae7394076b9e13d874402ac7cd1d3b3d80de21ca1e47e33d46930657bc32eea018ab263ac4010b340f8192fe9b22a0d443d030288479b74917021c60bf9e102b823d78a787f6a9ae292f832f8a78f5c6749edf7f7193122ec51df7bb9e259ded39f0965016b6caa8476cf40277f2fdbf17677edb98f668292c1c7cc15fb96211d6bb0693dfe59613a9373a63f203cd5cf5b70204a780bf15b190510d5fd1cec938c120a86a6e0a7567b37322c576754926413b4d8b8476dd930789521c6f3a1bf790b69830d3d28e34e7cb85bf6c16a3564f29ebbae2c6c965252966773235efb557ac95e7b8c57fb4450d4f5409cce4f01abab725227c195b0eac40f17e569b7c91083b02f640c1f1e4ad2ee4df654c99ebe37ef528059f342b7ae8f45ce9a35d7c93e31328f0a30aff574d2499de214d170e6c4a524450c7dc61badd74d56351ad2eb985b8332fee666b33b8cfc009013db68edef288ad381d4b4ba1f444f09c96ccac6c6b42ad29b944a3445f23d6e4ea34057b8dbeee9af7317e8e532bb5df9411374e08e93e6d87094ac525db062c3bd4490d377bb47888ce945d2afafefab87e0b7c5b4e5ec2ab038951e316c45bb0aa5380d139498411bfb7ece869cf4ae51cae8a4491d4179ca400bd9f432691aeba96c6de821fa382b65de0f37820bd4607874693225aaebec014d7aad6fe2f866bd4d39fa7c7115e149e16cb3a3460e701b5de064b4fb60fb0c98c76894411b87313861f9f17ae850c298f1cc5b6add78ccc8ba7140ed2844f0da796670d2abf93c424a4a622ff094436012806d0e50d6b51cb9458e55f587ddd4f22f9963368e2030bcf7a22ea191c9f67932bac51a056c76f06d7bd6fcd7959a8558edb4c3df804eb0c2376f2fcf69cd2c8e4d93d551209e231d319269ef5e9d8346c52c2a1e198020f481fe75923b79012a9bbdf54bf070c2e6d6e619f3ca639e4c161b8a023b18785fadbcc4d694aae9f06e3b9067b65eace6e34c81ddad1797eccd4412f0ba87614ddcfa26a701b7d003c05053a2a63cb3cb533ac1bdc293ad7ecb05a58aabcb5415171bda0412f31b7fadfd72adfea490ba6d5f445b54f30a9cd58b0adc502b0e1c57f61ce4d404f29b4e114de3ba8763ee5b4549eb102e049c24c48065814e1cba89bc08955a3c3c2bebf94076764cee6dacb2f35444a67d17e0f8e8f47b60c2baf346bc5cfb75cc089217d7646ea9428b75bec586c9d5ed829dd135975934f035d7286f1efd2f25ca7206210993473feecf50d64274020b2263814050684b4dc6c87884ff906ac83b0f912510a49963d5c4dcb30248a1d73b4bb761fa1ef15892de68960cd30a0d9fa6f7b80646e094a1abf2989204312481a886f0b50bb16971c3e8e623f2a27762c733141042eb8c66440053f11508c12c41d62671cb0393366068d481982b7d2090db618227a1ec120350f08cd488587908b6c17255d56074f19861ee5264f63adb2d5a5d28e72270a163e623b6cc2254652cf529f623beabe57a881bde8d10252015c90ee6a2780f6c6288323b23d15cc27a2d2e11b5a5c27c6a0dea26ee6c4b29828c1f9e0c4e252b4c742a02be8cf9e8aa43882de66c3dfda55d97b4c44c8e4e8c92289e962fe8a892b47a6f0d359bf012e6e814e86b887e36b8bacbb5a7142d2d61952d1bde635f80bacbc157446ec16346b48177250255fb8a3f2f6a1f270785359711f766674fc4389a133b3b26c979cbd9733d218693d69a44ec03cc04690ea8586969ae427bd8b4e5c04abe0aceb57042dae0dbd725f6b3a37f49ec72fc6bf9ecfeece0ba816bff2a009be35a61083a70fcd6cfdfec3db90ad65bb404a2c237ef8a0c23c65d1ed931250976f27dbd500d39f930bf7da747b35db07ff5c702d3003c269a902ed7808a3abc7616106c2d313faef262aead3e1d3b3caedc75c5d6e9194cab5028b85c523c438537eb7fdc0768f33eda01eb52e6388a8b56b6572f1d794b34ff1e8ae7e45341c0e673c5eab6c1030bc94e30229815f56efe90cf70a764574b8d6ccca364cb13d8d48eea687d117349fa2f1a0e4bafbe268f0598b051d93eac2bdbe73a43b5829724359429d5fae16368ec586954650b95a2ca5cc1b0a570919cdd2a018430690c63ef3b4fdf5e3aa82c4f29488b63eae90d2272dcedcca2d17c9d583b9f96148dd020dabdaa23c0b6fe585b729ff576dad89ea7ef5d5d698aeae1a565421a67f5e65021890f7c4bf6c2aeae8927d904bdbb72ad7d7a5f18f6ab5091163f7c75881118edcf5b6c57f75be5570213aae18ffc6487cf8393a8b73db873f77fcc30790d0f1c7f240e965d1d71c2a4556f462ee88d9b960b41eb1406341bb13c6cf1f1b7abd707063e04be30c6266dfb4679f3d3affa837336658b8f40cc5ba994f6e8e64d61b6d0aa1cb2e78ba738790f4750d65e3536033e556f86a761ed85790091dacf2acac2d7085c10a54ff32baa482aa7e467627778ec4113f46a8dd8499e98fe900678d6d3014c51ecb2db67a44e7e7a0f485c3b90673b555e937ce56d4a752cf503ac106e8a6d3b6186c935d556846eddd6d95893355fc95294dda4e1886ff659f6c567d6c033189827cd9be10d2e87f8e9863b3cbce9d0565f15747b60c90f90fdc531601183a990cd8b5b67ceb04d6fa5b7425a201fd80b3d61e1dbd625916bd2361ba7a49a8084c3b4e613a049c913b60f25d1b05a4574d61ba7e71390d828980d2744e7af4478ff2f4d1f3d084150052d43fab4e755827b5466e144b5a723c19a3403f9859fcaa86b67ac62b19882387f94132f6553489b5fdf7d0e580ef7809c95dedf20a6e2cc14d39e68af689ff4a5cb2d9a4572dbec7bb73c47c3bf1caa47a92097325fa1220d08d662f9b102aea40197131c9b568939b905ed145cd402b83b7ffdb34e685576a67eecedd686a29360e110e4fc0083a6d2cab97b74fe22870e59bbf2e857b416708018397b7e77cc3d2957fca5604d48dc058c75ceb62acb48ecc1a6cfbc3c8f108bab30e41b70c33a3a5719b3ce6e42978799c34c7ba56dc8e6799c31b5fb6c86b2065ec41b5fb7a3db5c1a05ab4f7642f11d77d57c9bb74c575183c7bbdb27b71ad059b5ec84661081bf8ddfeeb548215c194217e2ad4e1471c48e6c93bca7f07dbf3556b6fb33940afdfdad149be1b652087e168c253c938fe0af000cb0d2e908e5e1cf4d854044e60240577581256143cbb86af8239d564dea55319f39f529f59089a908103b6463bfa6b3ff1e7c649f02f1c57eadd392ad456889925291921fbd70367f285819da9b9690dec8649ba9fea0f20ce79278ca59dc1ec586cd308b39092b062e0ebf6283fa032aee6b7e2c1d758492cacf5a5f7352419d6a2b7bb6221ed1c74a7226924a72f0586f3614aeee21d4c4df3ecf1d18a300dac86674047e9743c4a325dd6289db9c9540d1743042d10841ad9fc2f06f2d3750a126ae705e3b0e4d3fe8d983663c16ec9e1d773f521d2407de4f2927da94420d3cb66b5a69e9dbb079d8ba3b919d2de7c83b4d8541885aab03b3fa8365e5ae1ba9ab9d1eb9d73de9945c6986f94cff8c4bb9172ccdce7d6e52dcfba08a7323c6849a2b694f381c9c069125684def30d86a9adf27ad33c58221a5e322b6b90224d57741617d35ad8b356bf58dd270b4569c084ffb3fe05ab3075b368a92dfa87a2d6649c2f351486433f2dbff1067049ad3393bd64a271cc2498cd1fbef224bc9dfb4a81135357ed5b6aba6fa1f23acacd98c217134a343c4099f8c8c4f7d9858f5a35cc4cef002b42b1cdec6c3229a1630ed2b075905b28eedc60ad3bf11e28592475725a1458f5c07a6c30d408aa7e448f50f6de036c5af81eaeebe99df0cb005126d5c8a05a72269045704cc30e8b63099838fc2222fa73a236b8b0f15220b1f7aa4f449a1a8120afb9e58e5a9d0f613641e7f26f4c7b9dfce30540afbb7d52f60b57a1e6969684fe470377ee8967ee94a429ce84f8439875c82c6605b514b54f2da9e0dae8bdb00d53b48375ea53bb3b1eca9efc0c021b6824c15ad1de99fb968cf17414be26e38e10c85954384773911ac619f9ca3db5afa77d75d68a8bfceddf6a839aeaa1b1ed89823ea71c10a43febbfa98b8e2ff6d7f08ccab03c5fc110f8033f7377f5123615297c362837ffabffa7c67779516113c8d590a5a07382dc452d27ae816204db6fee2d9d803897dae85275ca4a4ce70492e60b860abdfd7fc85ce789b71d53cb93e790e024423055534bce2e9a4e84093fd9781269b77ddea004596728a2b85771fd540847a95feca1b759ceda60505e9f833b77b737cb6aea82bbdb3f0a11451bb9a89517cac15a2c37d720c73b5c26f1bd1c9c6f5e1d3bbb70614de5378b325e77258ca6e8f471cce9e41e51c2b1bf316fe49d800117353d9e13145e58ab782ee6e2fd27c7fc8b1f2aa504588e76cd49210b9d0516574e4ff641c1b2adefe08d612cf1e647076c1de2fb8ee80d106ce54e462bf03da76f4ced21b243322fbb7131a1608423ba4b5ac706cfe568207c5170908cb3c778349c8e605fdc229347b6830c0c5f9c5b820cfb555c18e5bb19bbc01c903d7ea9820da08bf71c5aa03edad8128497cc074ef7c931640aab9a5b221bbe369d2c64e2cce40d243b59422764e72e92b131a8436b60d69a9a20c04c2913d0fec5f6bc2f07e169148f825dcd5f19c43f54b7fa9d64a6bc6b1a424c38627fdbb200d79b36f99a13e7a419c8297b5a3c7eea0012d627a3ff5be86c6511ece1a85a6c5dfbbf9c3fe98102e431feeaa76cde221446696012047f547f90e72bd8cb89abb5eec9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c2d4895aa35c24623105b30454823a80"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
